/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./js_src/draw/colors.js":
/*!*******************************!*\
  !*** ./js_src/draw/colors.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.get_colors = get_colors;\nexports.get_colors_inner = get_colors_inner;\nvar colors_cache = {};\nfunction get_colors(num_colors) {\n    if (!(num_colors in colors_cache)) {\n        colors_cache[num_colors] = get_colors_inner(num_colors);\n    }\n    return colors_cache[num_colors];\n}\nfunction get_colors_inner(num_colors) {\n    var lum_rows;\n    var hue_rows;\n    var lums;\n    if (num_colors <= 10) {\n        lum_rows = 1;\n        hue_rows = num_colors;\n        lums = [0.5];\n    }\n    else if (num_colors <= 20) {\n        lum_rows = 2;\n        hue_rows = Math.ceil(num_colors / 2);\n        lums = [0.33, 0.66];\n    }\n    else {\n        lum_rows = 3;\n        hue_rows = Math.ceil(num_colors / 3);\n        lums = [0.25, 0.5, 0.75];\n    }\n    var row_offset = Math.ceil(hue_rows / lum_rows);\n    var out = [];\n    var hue_step = half_coprime(hue_rows);\n    for (var i = 0; i < num_colors; i++) {\n        var lum_idx = Math.floor(i / hue_rows);\n        var hue_idx = (hue_step * i + lum_idx * row_offset) % hue_rows;\n        var lum = lums[lum_idx];\n        var hue = skip_yellow(hue_idx / hue_rows);\n        var color = hsl_to_rgb(hue, 0.65, lum);\n        out.push(\"rgb(\".concat(color[0], \", \").concat(color[1], \", \").concat(color[2], \")\"));\n    }\n    return out;\n}\nfunction hsl_to_rgb(h, s, l) {\n    var c = (1 - Math.abs(2 * l - 1)) * s;\n    var hp = 6 * h;\n    var x = c * (1 - Math.abs(hp % 2 - 1));\n    var rgb1;\n    if (hp < 1) {\n        rgb1 = [c, x, 0];\n    }\n    else if (hp < 2) {\n        rgb1 = [x, c, 0];\n    }\n    else if (hp < 3) {\n        rgb1 = [0, c, x];\n    }\n    else if (hp < 4) {\n        rgb1 = [0, x, c];\n    }\n    else if (hp < 5) {\n        rgb1 = [x, 0, c];\n    }\n    else {\n        rgb1 = [c, 0, x];\n    }\n    var intscale = function (x) { return Math.floor(x * 255); };\n    var m = l - c / 2;\n    return [\n        intscale(rgb1[0] + m),\n        intscale(rgb1[1] + m),\n        intscale(rgb1[2] + m),\n    ];\n}\nfunction half_coprime(n) {\n    for (var i = Math.floor(n / 2); i >= 1; i++)\n        if (gcd(n, i) == 1)\n            return i;\n    return 1; //Should never be run, but just in case.\n}\nfunction gcd(x, y) {\n    while (y) {\n        var t = y;\n        y = x % y;\n        x = t;\n    }\n    return x;\n}\nfunction skip_yellow(x) {\n    var interp = (70 / 360) + (1 + 40 / 360 - 70 / 360) * x;\n    return interp % 1;\n}\n\n\n//# sourceURL=webpack://dkk/./js_src/draw/colors.js?");

/***/ }),

/***/ "./js_src/draw/dag_layout.js":
/*!***********************************!*\
  !*** ./js_src/draw/dag_layout.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FramedDAGEmbedding = exports.AngleOverride = void 0;\nvar dag_1 = __webpack_require__(/*! ../math/dag */ \"./js_src/math/dag.js\");\nvar result_1 = __webpack_require__(/*! ../util/result */ \"./js_src/util/result.js\");\nvar num_1 = __webpack_require__(/*! ../util/num */ \"./js_src/util/num.js\");\nvar AngleOverride = /** @class */ (function () {\n    function AngleOverride(type, angle) {\n        this.type = type;\n        this.inner = angle;\n    }\n    AngleOverride.prototype.get_vector = function (default_angle, direction_vec, scale) {\n        if (this.type == \"none\")\n            return direction_vec.rot(default_angle).scale(scale);\n        if (this.type == \"relative\")\n            return direction_vec.rot(this.inner).scale(scale);\n        if (this.type == \"absolute\")\n            return num_1.Vector2.right().rot(this.inner).scale(scale);\n        if (this.type == \"vec-abs\")\n            return this.inner;\n        throw new Error(\"Unhandled branch\");\n    };\n    AngleOverride.none = function () {\n        return new AngleOverride(\"none\", 0);\n    };\n    AngleOverride.absolute = function (ang) {\n        return new AngleOverride(\"absolute\", ang);\n    };\n    AngleOverride.relative = function (ang) {\n        return new AngleOverride(\"relative\", ang);\n    };\n    AngleOverride.vec_abs = function (vec) {\n        return new AngleOverride(\"vec-abs\", vec);\n    };\n    //This exists for things loaded from JSON.\n    AngleOverride.from_json_ob = function (obj) {\n        for (var _i = 0, _a = [\"inner\", \"type\"]; _i < _a.length; _i++) {\n            var field = _a[_i];\n            if (!(field in obj))\n                return result_1.Result.err(\"MissingField\", \"AngleOverride missing field '\" + field + \"'.\");\n        }\n        var x = obj;\n        if (!([\"none\", \"absolute\", \"relative\", \"vec-abs\"].includes(x.type)))\n            return result_1.Result.err(\"InvalidData\", \"AngleOverride type invalid.\");\n        var inner = x.inner;\n        if (typeof inner != \"number\") {\n            if (!(\"x\" in inner) || !(\"y\" in inner))\n                return result_1.Result.err(\"InvalidData\", \"AngleOverride inner value invalid.\");\n            if (typeof inner.x != \"number\" || typeof inner.y != \"number\")\n                return result_1.Result.err(\"InvalidData\", \"AngleOverride inner value invalid.\");\n            inner = new num_1.Vector2(inner.x, inner.y);\n        }\n        return result_1.Result.ok(new AngleOverride(x.type, x.inner));\n    };\n    return AngleOverride;\n}());\nexports.AngleOverride = AngleOverride;\nvar FramedDAGEmbedding = /** @class */ (function () {\n    function FramedDAGEmbedding(dag) {\n        this.dag = dag.clone();\n        this.vert_data = Array.from({ length: dag.num_verts() }, function () { return ({\n            position: num_1.Vector2.zero(),\n            spread_out: Math.PI / 2,\n            spread_in: Math.PI / 2\n        }); });\n        this.edge_data = Array.from({ length: dag.num_edges() }, function () { return ({\n            start_list_pos: [1, 1],\n            end_list_pos: [1, 1],\n            start_ang_override: AngleOverride.none(),\n            end_ang_override: AngleOverride.none(),\n        }); });\n        this.default_layout();\n    }\n    FramedDAGEmbedding.prototype.default_layout = function () {\n        this.default_edges();\n        this.default_verts();\n    };\n    FramedDAGEmbedding.prototype.default_edges = function () {\n        this.edge_data = Array.from({ length: this.dag.num_edges() }, function () { return ({\n            start_list_pos: [1, 1],\n            end_list_pos: [1, 1],\n            start_ang_override: AngleOverride.none(),\n            end_ang_override: AngleOverride.none(),\n        }); });\n        this.recomp_list_pos();\n    };\n    FramedDAGEmbedding.prototype.default_verts = function () {\n        var _this = this;\n        this.vert_data = Array.from({ length: this.dag.num_verts() }, function () { return ({\n            position: num_1.Vector2.zero(),\n            spread_out: Math.PI / 2,\n            spread_in: Math.PI / 2\n        }); });\n        var depths_arr = [];\n        for (var i = 0; i < this.dag.num_verts(); i++) {\n            depths_arr.push(i);\n        }\n        depths_arr.sort(function (a, b) {\n            if (_this.dag.preceeds(a, b)) {\n                return -1;\n            }\n            else if (_this.dag.preceeds(b, a)) {\n                return 1;\n            }\n            return a - b;\n        });\n        for (var j = 0; j < depths_arr.length; j++) {\n            var index = depths_arr[j];\n            var vd = this.vert_data[index];\n            vd.position = new num_1.Vector2(j - (depths_arr.length - 1) / 2, 0);\n        }\n    };\n    FramedDAGEmbedding.prototype.recomp_list_pos = function () {\n        for (var v = 0; v < this.dag.num_verts(); v++) {\n            var out_edges = this.dag.get_out_edges(v).unwrap();\n            for (var i = 0; i < out_edges.length; i++) {\n                var edge = out_edges[i];\n                this.edge_data[edge].start_list_pos = [i, out_edges.length];\n                0.5;\n            }\n            var in_edges = this.dag.get_in_edges(v).unwrap();\n            for (var i = 0; i < in_edges.length; i++) {\n                var edge = in_edges[i];\n                this.edge_data[edge].end_list_pos = [i, in_edges.length];\n            }\n        }\n    };\n    FramedDAGEmbedding.prototype.bake = function () {\n        var verts = [];\n        var edges = [];\n        var vert_in_out = [];\n        for (var _i = 0, _a = this.vert_data; _i < _a.length; _i++) {\n            var x = _a[_i];\n            verts.push(x.position.clone());\n        }\n        for (var i = 0; i < this.dag.num_verts(); i++) {\n            var before = [];\n            for (var _b = 0, _c = this.dag.get_in_edges(i).unwrap(); _b < _c.length; _b++) {\n                var edge = _c[_b];\n                var start = this.dag.get_edge(edge).unwrap().start;\n                if (!before.includes(start))\n                    before.push(start);\n            }\n            var after = [];\n            for (var _d = 0, _e = this.dag.get_out_edges(i).unwrap(); _d < _e.length; _d++) {\n                var edge = _e[_d];\n                var end = this.dag.get_edge(edge).unwrap().end;\n                if (!after.includes(end))\n                    after.push(end);\n            }\n            var before_avg = num_1.Vector2.zero();\n            var after_avg = num_1.Vector2.zero();\n            for (var _f = 0, before_1 = before; _f < before_1.length; _f++) {\n                var b = before_1[_f];\n                before_avg = before_avg.add(verts[b].scale(1 / before.length));\n            }\n            for (var _g = 0, after_1 = after; _g < after_1.length; _g++) {\n                var a = after_1[_g];\n                after_avg = after_avg.add(verts[a].scale(1 / after.length));\n            }\n            vert_in_out.push([\n                verts[i].sub(before_avg).normalized(),\n                after_avg.sub(verts[i]).normalized(),\n            ]);\n        }\n        for (var i = 0; i < this.dag.num_edges(); i++) {\n            var edge = this.dag.get_edge(i).unwrap();\n            var edge_data = this.edge_data[i];\n            var start_data = this.vert_data[edge.start];\n            var end_data = this.vert_data[edge.end];\n            var start_pos = start_data.position;\n            var end_pos = end_data.position;\n            var delta = end_pos.sub(start_pos);\n            var tan_len = delta.norm() / 2;\n            var spread_percents = spread_percent(edge_data);\n            var start_tan = edge_data.start_ang_override\n                .get_vector(spread_percents[0] * start_data.spread_out, vert_in_out[edge.start][1], tan_len);\n            var end_tan = edge_data.end_ang_override\n                .get_vector(-spread_percents[1] * end_data.spread_in, vert_in_out[edge.end][0], tan_len);\n            var cp1 = start_pos.add(start_tan);\n            var cp2 = end_pos.sub(end_tan);\n            var bez = new num_1.Bezier(start_pos, cp1, cp2, end_pos);\n            edges.push(bez);\n        }\n        return {\n            verts: verts,\n            edges: edges\n        };\n    };\n    FramedDAGEmbedding.prototype.remove_edge = function (idx) {\n        if (this.dag.remove_edge(idx)) {\n            this.edge_data.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    FramedDAGEmbedding.prototype.add_edge = function (start, end) {\n        var res = this.dag.add_edge(start, end);\n        if (res.is_ok()) {\n            this.edge_data.push({\n                start_list_pos: [1, 1],\n                end_list_pos: [1, 1],\n                start_ang_override: AngleOverride.none(),\n                end_ang_override: AngleOverride.none(),\n            });\n            this.recomp_list_pos();\n        }\n        return res;\n    };\n    FramedDAGEmbedding.prototype.to_json_ob = function () {\n        return {\n            dag: this.dag.to_json_ob(),\n            vert_data: structuredClone(this.vert_data),\n            edge_data: structuredClone(this.edge_data)\n        };\n    };\n    FramedDAGEmbedding.prototype.to_json = function () {\n        return JSON.stringify(this.to_json_ob());\n    };\n    FramedDAGEmbedding.from_json = function (json) {\n        var obj;\n        try {\n            obj = JSON.parse(json);\n        }\n        catch (_a) {\n            return result_1.Result.err(\"InvalidJSON\", \"JSON file was malformed.\");\n        }\n        for (var _i = 0, _b = [\"dag\", \"vert_data\", \"edge_data\"]; _i < _b.length; _i++) {\n            var field = _b[_i];\n            if (!(field in obj))\n                return result_1.Result.err(\"MissingField\", \"JSON missing field '\" + field + \"'.\");\n        }\n        var data = obj;\n        var dag = dag_1.FramedDAG.from_json_ob(data.dag);\n        if (dag.is_err())\n            return dag.err_to_err();\n        var emb = new FramedDAGEmbedding(dag.unwrap());\n        emb.vert_data = data.vert_data;\n        emb.edge_data = data.edge_data;\n        //So they get their prototypes\n        for (var _c = 0, _d = emb.vert_data; _c < _d.length; _c++) {\n            var vd = _d[_c];\n            if (!(\"x\" in vd.position) || !(\"y\" in vd.position) ||\n                typeof vd.position.x != \"number\" || typeof vd.position.y != \"number\")\n                return result_1.Result.err(\"InvalidData\", \"Vertex position not a valid vector.\");\n            vd.position = new num_1.Vector2(vd.position.x, vd.position.y);\n        }\n        for (var _e = 0, _f = emb.edge_data; _e < _f.length; _e++) {\n            var ed = _f[_e];\n            var end_override = AngleOverride.from_json_ob(ed.end_ang_override);\n            var start_override = AngleOverride.from_json_ob(ed.start_ang_override);\n            if (end_override.is_err())\n                return end_override.err_to_err();\n            if (start_override.is_err())\n                return start_override.err_to_err();\n            ed.end_ang_override = end_override.unwrap();\n            ed.start_ang_override = start_override.unwrap();\n        }\n        return result_1.Result.ok(emb);\n    };\n    return FramedDAGEmbedding;\n}());\nexports.FramedDAGEmbedding = FramedDAGEmbedding;\nfunction spread_percent(edge_data) {\n    var out = [0, 0];\n    var start_end = [edge_data.start_list_pos, edge_data.end_list_pos];\n    for (var i = 0; i < 2; i++) {\n        if (start_end[i][1] > 1)\n            out[i] = start_end[i][0] / (start_end[i][1] - 1) - 0.5;\n    }\n    return out;\n}\n\n\n//# sourceURL=webpack://dkk/./js_src/draw/dag_layout.js?");

/***/ }),

/***/ "./js_src/draw/draw_options.js":
/*!*************************************!*\
  !*** ./js_src/draw/draw_options.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DrawOptions = void 0;\nvar cookie_1 = __webpack_require__(/*! ../util/cookie */ \"./js_src/util/cookie.js\");\nvar colors_1 = __webpack_require__(/*! ./colors */ \"./js_src/draw/colors.js\");\nvar ROUTE_RAINBOW = [\n    \"#5b4db7\",\n    \"#42adc7\",\n    \"#81d152\",\n    \"#f5f263\",\n    \"#ff9d4f\",\n    \"#ff5347\",\n];\nvar DRAW_OPTIONS_COOKIE_NAME = \"draw-options-cookie\";\nvar DrawOptions = /** @class */ (function () {\n    function DrawOptions(load_from_cookies, sync_css) {\n        this.f_scale = 200;\n        this.f_scheme_mode = { mode: \"computed\", index: 2 };\n        //DAG\n        this.f_edge_weight = 6;\n        this.f_vert_radius = 12;\n        this.f_route_weight = 8;\n        this.f_edge_halo = 6; //Not in settings\n        this.f_label_framing = true;\n        this.f_arrows = true;\n        //HASSE\n        this.f_hasse_edge_weight = 10;\n        this.f_hasse_show_cliques = true;\n        this.f_hasse_node_size = 10;\n        this.f_hasse_mini_dag_size = 80;\n        this.f_hasse_mini_vert_rad = 8;\n        this.f_hasse_mini_route_weight = 6;\n        //POLYTOPE\n        this.f_simplex_render_mode = \"dots\";\n        this.f_dot_shade = false;\n        this.f_dot_on_top = true;\n        this.f_dot_radius = 5;\n        //EDITOR\n        this.f_tangent_handle_size = 8;\n        this.f_tangent_arm_weight = 5;\n        //COLORS\n        this.f_background_color = \"#b0b0b0\";\n        this.f_vertex_color = \"#000000\";\n        this.f_polytope_color = \"#de5ed4\";\n        this.f_simplex_color = \"#c9e8f4\";\n        this.f_handle_color = \"#9a50d3\";\n        this.f_selection_color = \"#2160c487\"; //Not in settings box\n        this.f_edge_color = \"#222222\"; //Not in settings box\n        this.f_hasse_current_color = \"#cdcdcd\"; //Not in settings\n        this.f_hasse_node_color = \"#000000\";\n        this.f_hasse_current_node_color = \"#ffffff\";\n        //AUXILIARY\n        this.change_listeners = [];\n        this.do_sync_css = sync_css;\n        if (!load_from_cookies) {\n            this.sync_css();\n            return;\n        }\n        ;\n        var cookie_str = (0, cookie_1.get_cookie)(DRAW_OPTIONS_COOKIE_NAME);\n        if (!cookie_str)\n            return;\n        var json_ob;\n        try {\n            json_ob = JSON.parse(cookie_str);\n        }\n        catch (e) {\n            console.warn(\"Failed to parse draw options cookie.\", e);\n            return;\n        }\n        for (var field in this) {\n            if (field.substring(0, 2) == \"f_\" && field in json_ob)\n                // @ts-ignore\n                this[field] = json_ob[field];\n        }\n        this.sync_css();\n    }\n    DrawOptions.prototype.add_change_listener = function (listener) {\n        this.change_listeners.push(listener);\n    };\n    DrawOptions.prototype.fire_change_listeners = function () {\n        for (var _i = 0, _a = this.change_listeners; _i < _a.length; _i++) {\n            var f = _a[_i];\n            try {\n                f();\n            }\n            catch (_b) { }\n        }\n    };\n    DrawOptions.prototype.clear_change_listeners = function () {\n        this.change_listeners = [];\n    };\n    DrawOptions.prototype.set_vert_radius = function (rad) {\n        this.f_vert_radius = rad;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_edge_weight = function (weight) {\n        this.f_edge_weight = weight;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_label_framing = function (b) {\n        this.f_label_framing = b;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_arrows = function (b) {\n        this.f_arrows = b;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_route_weight = function (weight) {\n        this.f_route_weight = weight;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_hasse_edge_weight = function (weight) {\n        this.f_hasse_edge_weight = weight;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_hasse_show_cliques = function (b) {\n        this.f_hasse_show_cliques = b;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_hasse_mini_vert_rad = function (r) {\n        this.f_hasse_mini_vert_rad = r;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_hasse_mini_route_weight = function (r) {\n        this.f_hasse_mini_route_weight = r;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_hasse_mini_dag_size = function (r) {\n        this.f_hasse_mini_dag_size = r;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_scale = function (scale) {\n        this.f_scale = scale;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_builtin_color_scheme = function (id) {\n        this.f_scheme_mode = {\n            mode: \"computed\",\n            index: id\n        };\n        this.on_change();\n    };\n    DrawOptions.prototype.set_simplex_render_mode = function (mode) {\n        if (mode == \"solid\" || mode == \"dots\" || mode == \"blank\") {\n            this.f_simplex_render_mode = mode;\n            this.on_change();\n        }\n        else {\n            console.warn(\"Tried to change to invalid simplex render mode!\");\n        }\n    };\n    DrawOptions.prototype.set_vertex_color = function (color) {\n        this.f_vertex_color = color;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_background_color = function (color) {\n        this.f_background_color = color;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_polytope_color = function (color) {\n        this.f_polytope_color = color;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_simplex_color = function (color) {\n        this.f_simplex_color = color;\n        this.on_change();\n    };\n    DrawOptions.prototype.hasse_node_size = function () {\n        return this.f_hasse_node_size;\n    };\n    DrawOptions.prototype.hasse_mini_vert_rad = function () {\n        return this.f_hasse_mini_vert_rad;\n    };\n    DrawOptions.prototype.hasse_mini_route_weight = function () {\n        return this.f_hasse_mini_route_weight;\n    };\n    DrawOptions.prototype.hasse_mini_dag_size = function () {\n        return this.f_hasse_mini_dag_size;\n    };\n    DrawOptions.prototype.set_dot_shade = function (b) {\n        this.f_dot_shade = b;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_dot_on_top = function (b) {\n        this.f_dot_on_top = b;\n        this.on_change();\n    };\n    DrawOptions.prototype.set_dot_radius = function (rad) {\n        this.f_dot_radius = rad;\n        this.on_change();\n    };\n    DrawOptions.prototype.save_to_cookies = function () {\n        //An awful hack to get around the fact that functions can't be cloned.\n        var cl_store = this.change_listeners;\n        this.change_listeners = [];\n        var struct = structuredClone(this);\n        delete struct.change_listeners;\n        this.change_listeners = cl_store;\n        var this_as_str = JSON.stringify(struct);\n        (0, cookie_1.set_cookie)(DRAW_OPTIONS_COOKIE_NAME, this_as_str, 1000000000);\n    };\n    DrawOptions.prototype.on_change = function () {\n        this.sync_css();\n        this.fire_change_listeners();\n        try {\n            this.save_to_cookies();\n        }\n        catch (e) {\n            console.warn(\"Failed to save draw settings as cookie!\", e);\n        }\n    };\n    DrawOptions.prototype.sync_css = function () {\n        if (!this.do_sync_css) {\n            return;\n        }\n        document.documentElement.style.setProperty(\"--draw-background\", this.background_color());\n    };\n    DrawOptions.prototype.get_route_color = function (i) {\n        var scheme;\n        if (this.f_scheme_mode.mode == \"computed\") {\n            scheme = (0, colors_1.get_colors)(this.f_scheme_mode.index);\n        }\n        else {\n            throw new Error(\"Impossible\");\n        }\n        return scheme[i % scheme.length];\n    };\n    DrawOptions.prototype.scale = function () {\n        return this.f_scale;\n    };\n    DrawOptions.prototype.vert_radius = function () {\n        return this.f_vert_radius;\n    };\n    DrawOptions.prototype.edge_weight = function () {\n        return this.f_edge_weight;\n    };\n    DrawOptions.prototype.edge_halo = function () {\n        return this.f_edge_halo;\n    };\n    DrawOptions.prototype.label_framing = function () {\n        return this.f_label_framing;\n    };\n    DrawOptions.prototype.arrows = function () {\n        return this.f_arrows;\n    };\n    DrawOptions.prototype.tangent_handle_size = function () {\n        return this.f_tangent_handle_size;\n    };\n    DrawOptions.prototype.tangent_arm_weight = function () {\n        return this.f_tangent_arm_weight;\n    };\n    DrawOptions.prototype.route_weight = function () {\n        return this.f_route_weight;\n    };\n    DrawOptions.prototype.hasse_edge_weight = function () {\n        return this.f_hasse_edge_weight;\n    };\n    DrawOptions.prototype.hasse_show_cliques = function () {\n        return this.f_hasse_show_cliques;\n    };\n    DrawOptions.prototype.background_color = function () {\n        return this.f_background_color;\n    };\n    DrawOptions.prototype.selection_color = function () {\n        return this.f_selection_color;\n    };\n    DrawOptions.prototype.edge_color = function () {\n        return this.f_edge_color;\n    };\n    DrawOptions.prototype.vertex_color = function () {\n        return this.f_vertex_color;\n    };\n    DrawOptions.prototype.polytope_color = function () {\n        return this.f_polytope_color;\n    };\n    DrawOptions.prototype.simplex_color = function () {\n        return this.f_simplex_color;\n    };\n    DrawOptions.prototype.hasse_current_color = function () {\n        return this.f_hasse_current_color;\n    };\n    DrawOptions.prototype.handle_color = function () {\n        return this.f_handle_color;\n    };\n    DrawOptions.prototype.hasse_node_color = function () {\n        return this.f_hasse_node_color;\n    };\n    DrawOptions.prototype.hasse_current_node_color = function () {\n        return this.f_hasse_current_color;\n    };\n    DrawOptions.prototype.simplex_render_mode = function () {\n        return this.f_simplex_render_mode;\n    };\n    DrawOptions.prototype.dot_shade = function () {\n        return this.f_dot_shade;\n    };\n    DrawOptions.prototype.dot_on_top = function () {\n        return this.f_dot_on_top;\n    };\n    DrawOptions.prototype.dot_radius = function () {\n        return this.f_dot_radius;\n    };\n    DrawOptions.prototype.reset = function () {\n        var def = new DrawOptions(false, false);\n        var old_mode = null;\n        if (this.f_scheme_mode.mode == \"computed\") {\n            old_mode = this.f_scheme_mode;\n        }\n        for (var field in def) {\n            if (field.substring(0, 2) == \"f_\")\n                // @ts-ignore\n                this[field] = def[field];\n        }\n        if (old_mode) {\n            this.f_scheme_mode = old_mode;\n        }\n        this.on_change();\n    };\n    return DrawOptions;\n}());\nexports.DrawOptions = DrawOptions;\n\n\n//# sourceURL=webpack://dkk/./js_src/draw/draw_options.js?");

/***/ }),

/***/ "./js_src/editor_options.js":
/*!**********************************!*\
  !*** ./js_src/editor_options.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EditorOptions = void 0;\nvar cookie_1 = __webpack_require__(/*! ./util/cookie */ \"./js_src/util/cookie.js\");\nvar EDITOR_OPTIONS_COOKIE_NAME = \"editor-options-cookie\";\nvar EditorOptions = /** @class */ (function () {\n    function EditorOptions() {\n        this.f_reembed_add = true;\n        this.f_reembed_remove = true;\n        this.f_reembed_swap = true;\n        var cookie_str = (0, cookie_1.get_cookie)(EDITOR_OPTIONS_COOKIE_NAME);\n        if (!cookie_str)\n            return;\n        var json_ob;\n        try {\n            json_ob = JSON.parse(cookie_str);\n        }\n        catch (e) {\n            console.warn(\"Failed to parse editor options cookie.\", e);\n            return;\n        }\n        for (var field in this) {\n            if (field.substring(0, 2) == \"f_\" && field in json_ob)\n                // @ts-ignore\n                this[field] = json_ob[field];\n        }\n    }\n    EditorOptions.prototype.set_reembed_add = function (b) {\n        this.f_reembed_add = b;\n        this.save_to_cookies();\n    };\n    EditorOptions.prototype.set_reembed_remove = function (b) {\n        this.f_reembed_remove = b;\n        this.save_to_cookies();\n    };\n    EditorOptions.prototype.set_reembed_swap = function (b) {\n        this.f_reembed_swap = b;\n        this.save_to_cookies();\n    };\n    EditorOptions.prototype.reembed_add = function () {\n        return this.f_reembed_add;\n    };\n    EditorOptions.prototype.reembed_remove = function () {\n        return this.f_reembed_remove;\n    };\n    EditorOptions.prototype.reembed_swap = function () {\n        return this.f_reembed_swap;\n    };\n    EditorOptions.prototype.save_to_cookies = function () {\n        //An awful hack to get around the fact that functions can't be cloned.\n        var struct = structuredClone(this);\n        var this_as_str = JSON.stringify(struct);\n        (0, cookie_1.set_cookie)(EDITOR_OPTIONS_COOKIE_NAME, this_as_str, 1000000000);\n    };\n    return EditorOptions;\n}());\nexports.EditorOptions = EditorOptions;\n\n\n//# sourceURL=webpack://dkk/./js_src/editor_options.js?");

/***/ }),

/***/ "./js_src/html_elems.js":
/*!******************************!*\
  !*** ./js_src/html_elems.js ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RIGHT_AREA = exports.SIDEBAR_CONTENTS = exports.SIDEBAR_HEAD = void 0;\nexports.SIDEBAR_HEAD = document.getElementById(\"sb-head\");\nexports.SIDEBAR_CONTENTS = document.getElementById(\"sb-contents\");\nexports.RIGHT_AREA = document.getElementById(\"right_area\");\n\n\n//# sourceURL=webpack://dkk/./js_src/html_elems.js?");

/***/ }),

/***/ "./js_src/index.js":
/*!*************************!*\
  !*** ./js_src/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar main_1 = __webpack_require__(/*! ./main */ \"./js_src/main.js\");\nvar dkk = new main_1.DKKProgram();\n\n\n//# sourceURL=webpack://dkk/./js_src/index.js?");

/***/ }),

/***/ "./js_src/main.js":
/*!************************!*\
  !*** ./js_src/main.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DKKProgram = void 0;\nvar dag_layout_1 = __webpack_require__(/*! ./draw/dag_layout */ \"./js_src/draw/dag_layout.js\");\nvar draw_options_1 = __webpack_require__(/*! ./draw/draw_options */ \"./js_src/draw/draw_options.js\");\nvar dag_1 = __webpack_require__(/*! ./math/dag */ \"./js_src/math/dag.js\");\nvar clique_viewer_1 = __webpack_require__(/*! ./modes/clique_viewer */ \"./js_src/modes/clique_viewer.js\");\nvar embedding_editor_1 = __webpack_require__(/*! ./modes/embedding_editor */ \"./js_src/modes/embedding_editor.js\");\nvar cv_open_1 = __webpack_require__(/*! ./popup/cv-open */ \"./js_src/popup/cv-open.js\");\nvar ee_open_1 = __webpack_require__(/*! ./popup/ee-open */ \"./js_src/popup/ee-open.js\");\nvar new_1 = __webpack_require__(/*! ./popup/new */ \"./js_src/popup/new.js\");\nvar settings_1 = __webpack_require__(/*! ./popup/settings */ \"./js_src/popup/settings.js\");\nvar preset_1 = __webpack_require__(/*! ./preset */ \"./js_src/preset.js\");\nvar DKKProgram = /** @class */ (function () {\n    function DKKProgram() {\n        var _this = this;\n        this.draw_options = new draw_options_1.DrawOptions(true, true);\n        this.mode = embedding_editor_1.EmbeddingEditor.destructive_new((0, preset_1.preset_dag_embedding)(\"cube\"), this.draw_options);\n        this.popup_open = false;\n        this.body = document.getElementsByTagName(\"body\")[0];\n        this.open_button = document.getElementById(\"open-button\");\n        this.open_button.onclick = function (ev) {\n            _this.open_button_click();\n        };\n        this.settings_button = document.getElementById(\"settings-button\");\n        this.settings_button.onclick = function (ev) {\n            _this.settings_button_click();\n        };\n        this.switch_button = document.getElementById(\"switch-button\");\n        this.switch_button.onclick = function (ev) {\n            _this.switch_button_click();\n        };\n        this.new_button = document.getElementById(\"new-button\");\n        this.new_button.onclick = function (ev) {\n            _this.new_button_click();\n        };\n        this.save_button = document.getElementById(\"save-button\");\n        this.save_button.onclick = function (ev) {\n            _this.save_button_click();\n        };\n        this.show_hide_items();\n    }\n    DKKProgram.prototype.open_button_click = function () {\n        if (this.popup_open) {\n            return;\n        }\n        this.popup_open = true;\n        if (this.mode.name() == \"clique-viewer\") {\n            new cv_open_1.CVOpenPopup(this.body, this);\n        }\n        else if (this.mode.name() == \"embedding-editor\") {\n            new ee_open_1.EEOpenPopup(this.body, this);\n        }\n    };\n    DKKProgram.prototype.settings_button_click = function () {\n        if (this.popup_open) {\n            return;\n        }\n        this.popup_open = true;\n        new settings_1.SettingsPopup(this.body, this);\n    };\n    DKKProgram.prototype.switch_button_click = function () {\n        if (this.popup_open) {\n            return;\n        }\n        var embedding = this.mode.current_embedding();\n        if (this.mode.name() == \"embedding-editor\" && !embedding.dag.valid()) {\n            alert(\"Can't view; not a connected DAG with one source and one sink!\");\n            return;\n        }\n        this.mode.clear_global_events();\n        if (this.mode.name() == \"embedding-editor\") {\n            this.mode = clique_viewer_1.CliqueViewer.destructive_new(embedding, this.draw_options);\n        }\n        else {\n            this.mode = embedding_editor_1.EmbeddingEditor.destructive_new(embedding, this.draw_options);\n        }\n        this.show_hide_items();\n    };\n    DKKProgram.prototype.new_button_click = function () {\n        if (this.popup_open) {\n            return;\n        }\n        this.popup_open = true;\n        var popup = new new_1.NewPopup(this.body, this);\n    };\n    DKKProgram.prototype.save_button_click = function () {\n        var json = this.mode.current_data_json();\n        var blob = new Blob([json], { type: 'text/json' });\n        var a = document.createElement(\"a\");\n        a.setAttribute('href', URL.createObjectURL(blob));\n        a.setAttribute('download', 'dag.json');\n        var ev = new MouseEvent(\"click\", {\n            \"view\": window,\n            \"bubbles\": true,\n            \"cancelable\": false\n        });\n        a.dispatchEvent(ev);\n    };\n    DKKProgram.prototype.show_hide_items = function () {\n        if (this.mode.name() == \"embedding-editor\") {\n            this.new_button.style.display = \"block\";\n        }\n        if (this.mode.name() == \"clique-viewer\") {\n            this.new_button.style.display = \"none\";\n        }\n    };\n    DKKProgram.prototype.set_dag = function (emb) {\n        if (this.mode.name() == \"clique-viewer\")\n            this.mode = clique_viewer_1.CliqueViewer.destructive_new(emb, this.draw_options);\n        else if (this.mode.name() == \"embedding-editor\")\n            this.mode = embedding_editor_1.EmbeddingEditor.destructive_new(emb, this.draw_options);\n    };\n    DKKProgram.prototype.set_new_clique = function (num_verts) {\n        var newblank = new dag_1.FramedDAG(num_verts);\n        var layout = new dag_layout_1.FramedDAGEmbedding(newblank);\n        this.mode = embedding_editor_1.EmbeddingEditor.destructive_new(layout, this.draw_options);\n    };\n    return DKKProgram;\n}());\nexports.DKKProgram = DKKProgram;\n\n\n//# sourceURL=webpack://dkk/./js_src/main.js?");

/***/ }),

/***/ "./js_src/math/dag.js":
/*!****************************!*\
  !*** ./js_src/math/dag.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FramedDAG = exports.dag_error_types = void 0;\nvar result_1 = __webpack_require__(/*! ../util/result */ \"./js_src/util/result.js\");\nexports.dag_error_types = {\n    NoSuchVertex: \"NoSuchVertex\",\n    IllegalCycle: \"IllegalCycle\",\n};\nvar FramedDAG = /** @class */ (function () {\n    function FramedDAG(num_verts) {\n        this.edges = [];\n        this.f_num_edges = 0;\n        this.f_num_verts = num_verts;\n        this.out_edges = [];\n        this.in_edges = [];\n        for (var i = 0; i < num_verts; i++) {\n            this.out_edges.push([]);\n            this.in_edges.push([]);\n        }\n    }\n    FramedDAG.prototype.valid_vert = function (v) {\n        return Number.isInteger(v) && v >= 0 && v < this.f_num_verts;\n    };\n    FramedDAG.prototype.valid_edge = function (v) {\n        return Number.isInteger(v) && v >= 0 && v < this.f_num_edges;\n    };\n    FramedDAG.prototype.num_edges = function () {\n        return this.f_num_edges;\n    };\n    FramedDAG.prototype.num_verts = function () {\n        return this.f_num_verts;\n    };\n    FramedDAG.prototype.get_edge = function (i) {\n        if (!this.valid_edge(i)) {\n            return result_1.Option.none();\n        }\n        return result_1.Option.some(structuredClone(this.edges[i]));\n    };\n    //If OK, returns index of new edge.\n    FramedDAG.prototype.add_edge = function (start, end) {\n        for (var _i = 0, _a = [[start, \"start\"], [end, \"end\"]]; _i < _a.length; _i++) {\n            var x = _a[_i];\n            var num = x[0];\n            var name_1 = x[1];\n            if (!this.valid_vert(num)) {\n                return result_1.Result.err(exports.dag_error_types.NoSuchVertex, \"Provided vertex with impossible index \" +\n                    num.toString() +\n                    \" for field \" +\n                    name_1 + \".\");\n            }\n        }\n        if (this.preceeds(end, start).unwrap_or(false)) {\n            return result_1.Result.err(exports.dag_error_types.IllegalCycle, \"End preceeds start, introducing illegal cycle.\");\n        }\n        var new_edge = this.f_num_edges;\n        this.f_num_edges += 1;\n        this.edges.push({ start: start, end: end });\n        this.out_edges[start].push(new_edge);\n        this.in_edges[end].push(new_edge);\n        return result_1.Result.ok(new_edge);\n    };\n    FramedDAG.prototype.remove_edge = function (idx) {\n        if (idx < 0 && idx >= this.edges.length)\n            return false;\n        var clear = function (lis) {\n            var out = [];\n            for (var _i = 0, lis_1 = lis; _i < lis_1.length; _i++) {\n                var x = lis_1[_i];\n                if (x < idx)\n                    out.push(x);\n                if (x > idx)\n                    out.push(x - 1);\n            }\n            return out;\n        };\n        this.edges.splice(idx, 1);\n        this.f_num_edges -= 1;\n        for (var i = 0; i < this.f_num_verts; i++) {\n            this.in_edges[i] = clear(this.in_edges[i]);\n            this.out_edges[i] = clear(this.out_edges[i]);\n        }\n        return true;\n    };\n    //checks if there is a path from start to end; err if verts not valid\n    FramedDAG.prototype.preceeds = function (start, end) {\n        for (var _i = 0, _a = [[start, \"start\"], [end, \"end\"]]; _i < _a.length; _i++) {\n            var x = _a[_i];\n            var num = x[0];\n            var name_2 = x[1];\n            if (!this.valid_vert(num)) {\n                return result_1.Result.err(exports.dag_error_types.NoSuchVertex, \"Provided vertex with impossible index \" +\n                    num.toString() +\n                    \" for field \" +\n                    name_2 + \".\");\n            }\n        }\n        var layer = [start];\n        while (layer.length > 0) {\n            var new_layer = [];\n            for (var _b = 0, _c = this.edges; _b < _c.length; _b++) {\n                var edge = _c[_b];\n                if (layer.includes(edge.start)) {\n                    if (edge.end == end) {\n                        return result_1.Result.ok(true);\n                    }\n                    new_layer.push(edge.end);\n                }\n            }\n            layer = new_layer;\n        }\n        return result_1.Result.ok(false);\n    };\n    //returns a copy of out edges\n    FramedDAG.prototype.get_out_edges = function (vert) {\n        if (!this.valid_vert(vert)) {\n            return result_1.Option.none();\n        }\n        return result_1.Option.some(__spreadArray([], this.out_edges[vert], true));\n    };\n    //returns a copy of in edges\n    FramedDAG.prototype.get_in_edges = function (vert) {\n        if (!this.valid_vert(vert)) {\n            return result_1.Option.none();\n        }\n        return result_1.Option.some(__spreadArray([], this.in_edges[vert], true));\n    };\n    FramedDAG.prototype.reorder_out_edges = function (vert, new_arr) {\n        if (!this.valid_vert(vert)) {\n            return false;\n        }\n        if (!valid_replacement(this.out_edges[vert], new_arr)) {\n            return false;\n        }\n        this.out_edges[vert] = new_arr;\n        return true;\n    };\n    FramedDAG.prototype.reorder_in_edges = function (vert, new_arr) {\n        if (!this.valid_vert(vert)) {\n            return false;\n        }\n        if (!valid_replacement(this.in_edges[vert], new_arr)) {\n            return false;\n        }\n        this.in_edges[vert] = new_arr;\n        return true;\n    };\n    FramedDAG.prototype.sources = function () {\n        var out = [];\n        for (var i = 0; i < this.f_num_verts; i++) {\n            if (this.in_edges[i].length == 0)\n                out.push(i);\n        }\n        return out;\n    };\n    FramedDAG.prototype.sinks = function () {\n        var out = [];\n        for (var i = 0; i < this.f_num_verts; i++) {\n            if (this.out_edges[i].length == 0)\n                out.push(i);\n        }\n        return out;\n    };\n    FramedDAG.prototype.source = function () {\n        var ls = this.sources();\n        if (ls.length == 1)\n            return result_1.Option.some(ls[0]);\n        return result_1.Option.none();\n    };\n    FramedDAG.prototype.sink = function () {\n        var ls = this.sinks();\n        if (ls.length == 1)\n            return result_1.Option.some(ls[0]);\n        return result_1.Option.none();\n    };\n    FramedDAG.prototype.clone = function () {\n        var out = new FramedDAG(this.f_num_verts);\n        out.f_num_verts = this.f_num_verts;\n        out.f_num_edges = this.f_num_edges;\n        out.out_edges = structuredClone(this.out_edges);\n        out.in_edges = structuredClone(this.in_edges);\n        out.edges = structuredClone(this.edges);\n        return out;\n    };\n    FramedDAG.prototype.valid = function () {\n        var onesource = this.sources().length == 1;\n        var onesink = this.sinks().length == 1;\n        //Should guarantee connectedness, as \n        //If there are two conn-components, they\n        //each have at least one source/sink\n        return onesink && onesource;\n    };\n    FramedDAG.prototype.to_json_ob = function () {\n        var obj = {\n            num_verts: this.num_verts(),\n            out_edges: structuredClone(this.out_edges),\n            in_edges: structuredClone(this.in_edges)\n        };\n        return obj;\n    };\n    FramedDAG.prototype.to_json = function () {\n        return JSON.stringify(this.to_json_ob());\n    };\n    FramedDAG.from_json_ob = function (data) {\n        var edges = {};\n        var max_edge = -1;\n        for (var v = 0; v < data.num_verts; v++) {\n            for (var _i = 0, _a = data.out_edges[v]; _i < _a.length; _i++) {\n                var e = _a[_i];\n                if (!(e in edges))\n                    edges[e] = [-1, -1];\n                if (edges[e][0] != -1)\n                    return result_1.Result.err(\"InvalidData\", \"Edge \".concat(e, \" has multiple start points.\"));\n                edges[e][0] = v;\n                max_edge = Math.max(e, max_edge);\n            }\n            for (var _b = 0, _c = data.in_edges[v]; _b < _c.length; _b++) {\n                var e = _c[_b];\n                if (!(e in edges))\n                    edges[e] = [-1, -1];\n                if (edges[e][1] != -1)\n                    return result_1.Result.err(\"InvalidData\", \"Edge \".concat(e, \" has multiple end points.\"));\n                edges[e][1] = v;\n                max_edge = Math.max(e, max_edge);\n            }\n        }\n        var num_edges = max_edge + 1;\n        var out = new FramedDAG(data.num_verts);\n        for (var e = 0; e < num_edges; e++) {\n            if (!(e in edges))\n                return result_1.Result.err(\"InvalidData\", \"Edge list not saturated.\");\n            var edge = edges[e];\n            if (edge[0] == -1)\n                return result_1.Result.err(\"InvalidData\", \"Edge \".concat(e, \" has no start point.\"));\n            if (edge[1] == -1)\n                return result_1.Result.err(\"InvalidData\", \"Edge \".concat(e, \" has no end point.\"));\n            var succ = out.add_edge(edge[0], edge[1]);\n            if (!succ.is_ok())\n                return succ.err_to_err();\n        }\n        for (var v = 0; v < data.num_verts; v++) {\n            var in_framing = data.in_edges[v];\n            var out_framing = data.out_edges[v];\n            var in_succ = out.reorder_in_edges(v, in_framing);\n            var out_succ = out.reorder_out_edges(v, out_framing);\n            //Is this possible, given how the rest of the function works?\n            if (!in_succ)\n                return result_1.Result.err(\"InvalidData\", \"In-ordering on vertex \".concat(v, \" invalid.\"));\n            if (!out_succ)\n                return result_1.Result.err(\"InvalidData\", \"Out-ordering on vertex \".concat(v, \" invalid.\"));\n        }\n        return result_1.Result.ok(out);\n    };\n    FramedDAG.from_json = function (str) {\n        var obj;\n        try {\n            obj = JSON.parse(str);\n        }\n        catch (_a) {\n            return result_1.Result.err(\"InvalidJSON\", \"JSON file was malformed.\");\n        }\n        for (var _i = 0, _b = [\"num_verts\", \"out_edges\", \"in_edges\"]; _i < _b.length; _i++) {\n            var field = _b[_i];\n            if (!(field in obj))\n                return result_1.Result.err(\"MissingField\", \"JSON missing field '\" + field + \"'.\");\n        }\n        var data = obj;\n        return FramedDAG.from_json_ob(data);\n    };\n    return FramedDAG;\n}());\nexports.FramedDAG = FramedDAG;\nfunction valid_replacement(arr1, arr2) {\n    if (arr1.length != arr2.length) {\n        return false;\n    }\n    var a1 = arr1.toSorted();\n    var a2 = arr2.toSorted();\n    for (var i = 0; i < a1.length; i++)\n        if (a1[i] != a2[i])\n            return false;\n    return true;\n}\n\n\n//# sourceURL=webpack://dkk/./js_src/math/dag.js?");

/***/ }),

/***/ "./js_src/math/hasse.js":
/*!******************************!*\
  !*** ./js_src/math/hasse.js ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HasseDiagram = void 0;\nvar num_1 = __webpack_require__(/*! ../util/num */ \"./js_src/util/num.js\");\nvar HasseDiagram = /** @class */ (function () {\n    function HasseDiagram(poset_relation, cliques) {\n        //Extracts the covering relation from the poset relation.\n        var covering_relation = structuredClone(poset_relation);\n        this.poset_size = covering_relation.length;\n        for (var clq1 = 0; clq1 < this.poset_size; clq1++) {\n            for (var clq2 = 0; clq2 < this.poset_size; clq2++) {\n                if (clq1 == clq2) {\n                    covering_relation[clq1][clq2] = false;\n                    continue;\n                }\n                if (!poset_relation[clq1][clq2])\n                    continue;\n                for (var clq_mid = 0; clq_mid < this.poset_size; clq_mid++) {\n                    if (clq_mid == clq1 || clq_mid == clq2)\n                        continue;\n                    if (poset_relation[clq1][clq_mid] && poset_relation[clq_mid][clq2]) {\n                        covering_relation[clq1][clq2] = false;\n                        break;\n                    }\n                }\n            }\n        }\n        this.covering_relation = covering_relation;\n        this.maximal_elt = -1;\n        this.minimal_elt = -1;\n        for (var i = 0; i < this.poset_size; i++) {\n            var num_geq = 0;\n            for (var j = 0; j < this.poset_size; j++) {\n                if (poset_relation[i][j])\n                    num_geq += 1;\n            }\n            if (num_geq == 1)\n                this.maximal_elt = i;\n            if (num_geq == this.poset_size)\n                this.minimal_elt = i;\n        }\n        this.layout_rows = HasseDiagram.compute_layout_rows(this.minimal_elt, this.covering_relation);\n        this.bounding_box = new num_1.BoundingBox(this.layout_rows);\n        this.cover_routes = [];\n        for (var i = 0; i < this.poset_size; i++) {\n            this.cover_routes.push([]);\n            for (var j = 0; j < this.poset_size; j++) {\n                if (!this.covering_relation[i][j]) {\n                    this.cover_routes[i].push([-1, -1]);\n                    continue;\n                }\n                var lo_clq = cliques[i];\n                var hi_clq = cliques[j];\n                var lo_route = -1;\n                var hi_route = -1;\n                for (var _i = 0, _a = lo_clq.routes; _i < _a.length; _i++) {\n                    var r = _a[_i];\n                    if (!hi_clq.routes.includes(r)) {\n                        lo_route = r;\n                        break;\n                    }\n                }\n                for (var _b = 0, _c = hi_clq.routes; _b < _c.length; _b++) {\n                    var r = _c[_b];\n                    if (!lo_clq.routes.includes(r)) {\n                        hi_route = r;\n                        break;\n                    }\n                }\n                if (lo_route == -1 || hi_route == -1) {\n                    console.warn(\"Clique covered by other clique do not differ as expected.\");\n                    this.cover_routes[i].push([-1, -1]);\n                }\n                this.cover_routes[i].push([lo_route, hi_route]);\n            }\n        }\n    }\n    HasseDiagram.compute_layout_rows = function (min, covering_relation) {\n        var max_depths = [];\n        for (var i = 0; i < covering_relation.length; i++) {\n            max_depths.push(0);\n        }\n        var srch = [min];\n        var cur_depth = 0;\n        while (srch.length != 0) {\n            var next_row = [];\n            for (var _i = 0, srch_1 = srch; _i < srch_1.length; _i++) {\n                var s = srch_1[_i];\n                max_depths[s] = cur_depth;\n                for (var i = 0; i < covering_relation.length; i++)\n                    if (covering_relation[s][i])\n                        next_row.push(i);\n            }\n            cur_depth += 1;\n            srch = next_row;\n        }\n        var max_depth = max_depths.reduce(function (a, b) { return Math.max(a, b); }, 0);\n        var rows = [];\n        for (var d = 0; d <= max_depth; d++) {\n            var next_row = [];\n            for (var j = 0; j < max_depths.length; j++)\n                if (max_depths[j] == d)\n                    next_row.push(j);\n            if (next_row.length > 0)\n                rows.push(next_row);\n        }\n        var edges = [];\n        for (var i = 0; i < covering_relation.length; i++)\n            for (var j = 0; j < covering_relation.length; j++)\n                if (covering_relation[i][j])\n                    edges.push([i, j]);\n        var row_of = {};\n        for (var i = 0; i < rows.length; i++)\n            for (var _a = 0, _b = rows[i]; _a < _b.length; _a++) {\n                var e = _b[_a];\n                row_of[e] = i;\n            }\n        var dummy = -1;\n        var get_dummy = function () {\n            dummy -= 1;\n            return dummy;\n        };\n        var extended_edges = [];\n        var extended_rows = structuredClone(rows);\n        for (var _c = 0, edges_1 = edges; _c < edges_1.length; _c++) {\n            var edge = edges_1[_c];\n            var i = edge[0], j = edge[1];\n            var row_i = row_of[i];\n            var row_j = row_of[j];\n            if (row_of[j] - row_of[i] == 1)\n                extended_edges.push([i, j]);\n            else {\n                var dummies = [];\n                for (var r = row_i + 1; r < row_j; r++) {\n                    var d = get_dummy();\n                    dummies.push(d);\n                    row_of[d] = r;\n                    extended_rows[r].push(d);\n                }\n                extended_edges.push([i, dummies[0]]);\n                for (var d_idx = 0; d_idx < dummies.length - 1; d_idx++) {\n                    extended_edges.push([\n                        dummies[d_idx],\n                        dummies[d_idx + 1]\n                    ]);\n                }\n                extended_edges.push([dummies[dummies.length - 1], j]);\n            }\n        }\n        for (var _d = 0, extended_rows_1 = extended_rows; _d < extended_rows_1.length; _d++) {\n            var row = extended_rows_1[_d];\n            row.sort();\n        }\n        var badness = function () { return HasseDiagram.comp_badness(extended_rows, edges, row_of); };\n        while (true) {\n            var start_val = badness();\n            var _loop_1 = function (depth) {\n                var swap = function (x, y) {\n                    var _a;\n                    _a = [extended_rows[depth][y], extended_rows[depth][x]], extended_rows[depth][x] = _a[0], extended_rows[depth][y] = _a[1];\n                };\n                if (extended_rows[depth].length == 0)\n                    return \"continue\";\n                var depth_start_val = badness();\n                for (var i = 0; i < extended_rows[depth].length; i++) {\n                    var do_break = false;\n                    for (var j = i + 1; j < extended_rows[depth].length; j++) {\n                        swap(i, j);\n                        if (badness() < depth_start_val) {\n                            do_break = true;\n                            break;\n                        }\n                        swap(i, j);\n                    }\n                    if (do_break)\n                        break;\n                }\n            };\n            for (var depth = 0; depth < extended_rows.length; depth++) {\n                _loop_1(depth);\n            }\n            var end_val = badness();\n            if (start_val - end_val < 0.01)\n                break;\n        }\n        var positions = [];\n        for (var i = 0; i < covering_relation.length; i++) {\n            positions.push(num_1.Vector2.zero());\n        }\n        for (var row_depth = 0; row_depth < extended_rows.length; row_depth++) {\n            var row = extended_rows[row_depth];\n            for (var j = 0; j < row.length; j++) {\n                var idx = row[j];\n                if (idx < 0)\n                    continue;\n                var y = row_depth;\n                var x = j - (row.length - 1) / 2;\n                positions[idx] = new num_1.Vector2(x, y);\n            }\n        }\n        var avg = positions.reduce(function (acc, nw) { return acc.add(nw); }, num_1.Vector2.zero()).scale(1 / positions.length);\n        return positions\n            .map(function (v) { return v.sub(avg); });\n    };\n    HasseDiagram.comp_badness = function (extended_rows, edges, row_of) {\n        var badness = 0;\n        for (var _i = 0, edges_2 = edges; _i < edges_2.length; _i++) {\n            var e = edges_2[_i];\n            var pos = [0, 0];\n            for (var _a = 0, _b = [0, 1]; _a < _b.length; _a++) {\n                var i = _b[_a];\n                var row = row_of[e[i]];\n                var rpos = extended_rows[row].indexOf(e[i]);\n                var row_len = extended_rows[row].length;\n                pos[i] = rpos - (row_len - 1) / 2;\n            }\n            badness += Math.abs(pos[0] - pos[1]);\n        }\n        return badness;\n    };\n    return HasseDiagram;\n}());\nexports.HasseDiagram = HasseDiagram;\n\n\n//# sourceURL=webpack://dkk/./js_src/math/hasse.js?");

/***/ }),

/***/ "./js_src/math/polytope.js":
/*!*********************************!*\
  !*** ./js_src/math/polytope.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FlowPolytope = void 0;\nvar FlowPolytope = /** @class */ (function () {\n    function FlowPolytope(dag_cliques) {\n        var _this = this;\n        var unreduced_dim = dag_cliques.dag.num_edges();\n        this.dim = dag_cliques.dag.num_edges() - dag_cliques.dag.num_verts() + 1;\n        var unred_vertices = [];\n        for (var _i = 0, _a = dag_cliques.routes; _i < _a.length; _i++) {\n            var route = _a[_i];\n            var vertex = NVector.zero(unreduced_dim);\n            for (var _b = 0, _c = route.edges; _b < _c.length; _b++) {\n                var edge = _c[_b];\n                vertex.coordinates[edge] = 1;\n            }\n            unred_vertices.push(vertex);\n        }\n        var max_clique = dag_cliques.cliques[dag_cliques.hasse.maximal_elt];\n        var center = unred_vertices[max_clique.routes[0]];\n        var basis = max_clique.routes.slice(1)\n            .map(function (idx) {\n            return unred_vertices[idx].sub(center);\n        });\n        var centered_vertices = unred_vertices\n            .map(function (v) { return v.sub(center); });\n        var A = Matrix.from_columns(basis);\n        var E = Matrix.id(unreduced_dim);\n        var swap_both = function (i, j) {\n            A.swap_rows(i, j);\n            E.swap_rows(i, j);\n        };\n        var scale_both = function (i, scalar) {\n            A.scale_row(i, scalar);\n            E.scale_row(i, scalar);\n        };\n        var add_scaled_both = function (add_to, add_from, scalar) {\n            A.add_scaled_row(add_to, add_from, scalar);\n            E.add_scaled_row(add_to, add_from, scalar);\n        };\n        for (var c = 0; c < A.width; c++) {\n            if (A.get_entry(c, c) == 0) {\n                for (var r = c + 1; r < A.height; r++) {\n                    if (A.get_entry(r, c) != 0) {\n                        swap_both(c, r);\n                        break;\n                    }\n                }\n            }\n            scale_both(c, 1 / A.get_entry(c, c));\n            for (var i = 0; i < A.height; i++) {\n                if (c == i)\n                    continue;\n                add_scaled_both(i, c, -A.get_entry(i, c));\n            }\n        }\n        var projected_vertices = centered_vertices\n            .map(function (v) { return E.apply_to(v).trunc(_this.dim); });\n        if (this.dim == 3 || this.dim == 2) {\n            var _d = min_bounding_ellipsoid(projected_vertices), A_1 = _d.matrix, center_1 = _d.center;\n            var B_1 = cholesky_decomposition(A_1.inv());\n            //This has the property that B^T A B = I\n            //So, the map x -> B^(-1)(x-c) takes the ellipsoid given by\n            //(x-c)^TA(x-c)=1 to the unit sphere.\n            this.vertices = projected_vertices\n                .map(function (v) { return B_1.inv().apply_to(v.sub(center_1)).scale(0.95); });\n        }\n        else {\n            this.vertices = projected_vertices;\n        }\n        var external_simplices = [];\n        for (var clq_idx = 0; clq_idx < dag_cliques.cliques.length; clq_idx++) {\n            if (this.dim == 2) {\n                external_simplices.push(structuredClone(dag_cliques.cliques[clq_idx].routes));\n                continue;\n            }\n            var clq = dag_cliques.cliques[clq_idx];\n            var no_flip = [];\n            for (var route_idx = 0; route_idx < clq.routes.length; route_idx++) {\n                if (dag_cliques.route_swap_by_idx_in_clq(clq_idx, route_idx) == clq_idx) {\n                    no_flip.push(route_idx);\n                }\n            }\n            for (var _e = 0, no_flip_1 = no_flip; _e < no_flip_1.length; _e++) {\n                var skip = no_flip_1[_e];\n                var simpl = [];\n                for (var route_idx = 0; route_idx < clq.routes.length; route_idx++) {\n                    if (route_idx == skip)\n                        continue;\n                    simpl.push(clq.routes[route_idx]);\n                }\n                external_simplices.push(simpl);\n            }\n        }\n        this.external_simplices = external_simplices;\n    }\n    return FlowPolytope;\n}());\nexports.FlowPolytope = FlowPolytope;\nvar NVector = /** @class */ (function () {\n    function NVector(coordinates) {\n        this.coordinates = coordinates;\n    }\n    NVector.zero = function (dim) {\n        return new NVector(new Array(dim).fill(0));\n    };\n    NVector.one = function (dim) {\n        return new NVector(new Array(dim).fill(1));\n    };\n    NVector.prototype.norm = function () {\n        var out = 0;\n        for (var _i = 0, _a = this.coordinates; _i < _a.length; _i++) {\n            var c = _a[_i];\n            out += c * c;\n        }\n        return Math.sqrt(out);\n    };\n    NVector.prototype.dim = function () {\n        return this.coordinates.length;\n    };\n    NVector.prototype.add = function (vec) {\n        if (this.dim() != vec.dim()) {\n            throw new Error(\"Dimensions do not match.\");\n        }\n        var out = NVector.zero(this.dim());\n        for (var i = 0; i < this.dim(); i++) {\n            out.coordinates[i] = this.coordinates[i] + vec.coordinates[i];\n        }\n        return out;\n    };\n    NVector.prototype.scale = function (scalar) {\n        var out = NVector.zero(this.dim());\n        for (var i = 0; i < this.dim(); i++) {\n            out.coordinates[i] = scalar * this.coordinates[i];\n        }\n        return out;\n    };\n    NVector.prototype.sub = function (vec) {\n        return this.add(vec.scale(-1));\n    };\n    NVector.prototype.trunc = function (dim) {\n        var out = [];\n        for (var i = 0; i < Math.min(dim, this.dim()); i++)\n            out.push(this.coordinates[i]);\n        return new NVector(out);\n    };\n    NVector.prototype.dot = function (vec) {\n        if (vec.dim() != this.dim())\n            throw new Error(\"Dimensions don't match.\");\n        var out = 0;\n        for (var i = 0; i < this.dim(); i++)\n            out += this.coordinates[i] * vec.coordinates[i];\n        return out;\n    };\n    NVector.prototype.as_row_matrix = function () {\n        var inner = structuredClone(this.coordinates);\n        return new Matrix(this.dim(), 1, [inner]);\n    };\n    NVector.prototype.as_column_matrix = function () {\n        var inner = [];\n        for (var _i = 0, _a = this.coordinates; _i < _a.length; _i++) {\n            var x = _a[_i];\n            inner.push([x]);\n        }\n        return new Matrix(1, this.dim(), inner);\n    };\n    NVector.linearly_independent = function (vectors) {\n        throw new Error(\"Unimplemented.\");\n    };\n    return NVector;\n}());\nvar Matrix = /** @class */ (function () {\n    function Matrix(width, height, inner) {\n        this.inner = inner;\n        this.height = height;\n        this.width = width;\n    }\n    Matrix.zero = function (dim) {\n        var inner = [];\n        for (var i = 0; i < dim; i++) {\n            inner.push(new Array(dim).fill(0));\n        }\n        return new Matrix(dim, dim, inner);\n    };\n    Matrix.zero_rect = function (width, height) {\n        var inner = [];\n        for (var i = 0; i < height; i++) {\n            inner.push(new Array(width).fill(0));\n        }\n        return new Matrix(width, height, inner);\n    };\n    Matrix.id = function (dim) {\n        var m = Matrix.zero(dim);\n        for (var i = 0; i < dim; i++) {\n            m.inner[i][i] = 1;\n        }\n        return m;\n    };\n    Matrix.from_columns = function (columns) {\n        var col_dum = columns[0].dim();\n        var inner = [];\n        for (var r = 0; r < col_dum; r++) {\n            var row = [];\n            for (var c = 0; c < columns.length; c++) {\n                row.push(columns[c].coordinates[r]);\n            }\n            inner.push(row);\n        }\n        return new Matrix(columns.length, col_dum, inner);\n    };\n    Matrix.diag = function (vec) {\n        var mat = Matrix.zero(vec.dim());\n        for (var i = 0; i < vec.dim(); i++)\n            mat.inner[i][i] = vec.coordinates[i];\n        return mat;\n    };\n    Matrix.prototype.swap_rows = function (i, j) {\n        var _a;\n        for (var c = 0; c < this.width; c++) {\n            _a = [this.inner[j][c], this.inner[i][c]], this.inner[i][c] = _a[0], this.inner[j][c] = _a[1];\n        }\n    };\n    Matrix.prototype.scale_row = function (i, scalar) {\n        for (var c = 0; c < this.width; c++) {\n            this.inner[i][c] *= scalar;\n        }\n    };\n    Matrix.prototype.add_scaled_row = function (add_to, add_from, scalar) {\n        for (var c = 0; c < this.width; c++) {\n            this.inner[add_to][c] += this.inner[add_from][c] * scalar;\n        }\n    };\n    Matrix.prototype.get_col_vec = function (col) {\n        var out = [];\n        for (var r = 0; r < this.height; r++)\n            out.push(this.get_entry(r, col));\n        return new NVector(out);\n    };\n    Matrix.prototype.get_row_vec = function (row) {\n        var out = [];\n        for (var c = 0; c < this.width; c++)\n            out.push(this.get_entry(row, c));\n        return new NVector(out);\n    };\n    Matrix.prototype.get_entry = function (row, col) {\n        return this.inner[row][col];\n    };\n    Matrix.prototype.apply_to = function (vec) {\n        if (vec.dim() != this.width)\n            throw new Error(\"Dimensions don't match!\");\n        var out = NVector.zero(this.height);\n        for (var i = 0; i < this.width; i++) {\n            out = out.add(this.get_col_vec(i).scale(vec.coordinates[i]));\n        }\n        return out;\n    };\n    Matrix.prototype.t = function () {\n        var out = [];\n        for (var c = 0; c < this.width; c++) {\n            var row = [];\n            for (var r = 0; r < this.height; r++)\n                row.push(this.get_entry(r, c));\n            out.push(row);\n        }\n        return new Matrix(this.height, this.width, out);\n    };\n    Matrix.prototype.det = function () {\n        if (this.width != this.height)\n            throw new Error(\"Only square matrices have determinants.\");\n        if (this.width == 1)\n            return this.inner[0][0];\n        if (this.width == 2) {\n            var a = this.inner[0][0];\n            var b = this.inner[1][0];\n            var c = this.inner[0][1];\n            var d = this.inner[1][1];\n            return a * d - b * c;\n        }\n        var out = 0;\n        for (var r = 0; r < this.height; r++) {\n            var v = Math.pow(-1, r) * this.get_entry(r, 0);\n            var m = this.minor(r, 0);\n            out += v * m.det();\n        }\n        return out;\n    };\n    Matrix.prototype.inv = function () {\n        if (this.width != this.height)\n            throw new Error(\"Only square matrices have inverses.\");\n        var det = this.det();\n        if (det == 0)\n            throw new Error(\"Matrix not invertible.\");\n        var inverse = Matrix.zero(this.width);\n        for (var r = 0; r < this.height; r++) {\n            for (var c = 0; c < this.width; c++) {\n                inverse.inner[r][c] = Math.pow(-1, r + c) * this.minor(c, r).det() / det;\n            }\n        }\n        return inverse;\n    };\n    Matrix.prototype.diag_vector = function () {\n        var out = [];\n        var d = Math.min(this.height, this.width);\n        for (var i = 0; i < d; i++)\n            out.push(this.get_entry(i, i));\n        return new NVector(out);\n    };\n    Matrix.prototype.minor = function (rem_row, rem_col) {\n        var out = [];\n        for (var r = 0; r < this.height; r++) {\n            if (r == rem_row)\n                continue;\n            var row = [];\n            for (var c = 0; c < this.width; c++) {\n                if (c == rem_col)\n                    continue;\n                row.push(this.get_entry(r, c));\n            }\n            out.push(row);\n        }\n        return new Matrix(this.width - 1, this.height - 1, out);\n    };\n    Matrix.prototype.mul = function (rhs) {\n        if (this.width != rhs.height)\n            throw new Error(\"Dimensions don't match for matrix multiplication.\");\n        var out = Matrix.zero_rect(rhs.width, this.height);\n        for (var c = 0; c < out.width; c++)\n            for (var r = 0; r < out.height; r++) {\n                var rv = this.get_row_vec(r);\n                var cv = rhs.get_col_vec(c);\n                out.inner[r][c] = rv.dot(cv);\n            }\n        return out;\n    };\n    Matrix.prototype.add = function (rhs) {\n        if (this.width != rhs.width || this.height != rhs.height)\n            throw new Error(\"Dimensions don't match!\");\n        var out = Matrix.zero_rect(this.width, this.height);\n        for (var c = 0; c < this.width; c++) {\n            for (var r = 0; r < this.height; r++) {\n                out.inner[r][c] = this.inner[r][c] + rhs.inner[r][c];\n            }\n        }\n        return out;\n    };\n    Matrix.prototype.scale = function (k) {\n        var out = Matrix.zero_rect(this.width, this.height);\n        for (var c = 0; c < this.width; c++) {\n            for (var r = 0; r < this.height; r++) {\n                out.inner[r][c] = this.inner[r][c] * k;\n            }\n        }\n        return out;\n    };\n    Matrix.prototype.sub = function (rhs) {\n        return this.add(rhs.scale(-1));\n    };\n    Matrix.prototype.log_str = function () {\n        var out = \"\";\n        for (var _i = 0, _a = this.inner; _i < _a.length; _i++) {\n            var row = _a[_i];\n            for (var _b = 0, row_1 = row; _b < row_1.length; _b++) {\n                var v = row_1[_b];\n                out += v.toString();\n            }\n            out += \"\\n\";\n        }\n        return out;\n    };\n    return Matrix;\n}());\nfunction append_1_row(matrix) {\n    var inner = structuredClone(matrix.inner);\n    inner.push(new Array(matrix.width).fill(1));\n    return new Matrix(matrix.width, matrix.height + 1, inner);\n}\n//https://stackoverflow.com/questions/1768197/bounding-ellipse/1768440#1768440\n//https://people.orie.cornell.edu/miketodd/TYKhach.pdf\n//M matrix, C center\n//Ellipse is\n//(x-C)^T M (x-C) = 1\nfunction min_bounding_ellipsoid(points, tolerance) {\n    if (tolerance === void 0) { tolerance = 0.01; }\n    var N = points.length;\n    var P = Matrix.from_columns(points);\n    var d = points[0].dim();\n    var n = d + 1;\n    var Q = append_1_row(P);\n    var u = NVector.one(N).scale(1 / N);\n    var count = 1;\n    var err = 1;\n    while (err > tolerance) {\n        var X = Q.mul(Matrix.diag(u)).mul(Q.t());\n        var M = Q.t()\n            .mul(X.inv())\n            .mul(Q)\n            .diag_vector();\n        var max_loc = 0;\n        var max = M.coordinates[0];\n        for (var i = 1; i < M.dim(); i++) {\n            if (M.coordinates[i] > max) {\n                max = M.coordinates[i];\n                max_loc = i;\n            }\n        }\n        var step_size = (max - n) / (n * (max - 1));\n        var new_u = u.scale(1 - step_size);\n        new_u.coordinates[max_loc] += step_size;\n        err = new_u.sub(u).norm();\n        count += 1;\n        u = new_u;\n    }\n    var U = Matrix.diag(u);\n    var pup = P.mul(U).mul(P.t());\n    var center = P.apply_to(u);\n    var pupu = center.as_column_matrix()\n        .mul(center.as_row_matrix());\n    var A = pup.sub(pupu).inv().scale(1 / d);\n    //A = (1/d) * inv(P * U * P' - (P * u)*(P*u)' );\n    //c = P * u;\n    return {\n        matrix: A,\n        center: center\n    };\n}\nfunction cholesky_decomposition(A) {\n    var L = Matrix.zero(A.width).inner;\n    var n = A.width;\n    for (var i = 0; i < n; i++) {\n        for (var j = 0; j <= i; j++) {\n            var sum = 0;\n            for (var k = 0; k < j; k++)\n                sum += L[i][k] * L[j][k];\n            if (i == j)\n                L[i][j] = Math.sqrt(A.inner[i][i] - sum);\n            else\n                L[i][j] = (1.0 / L[j][j] * (A.inner[i][j] - sum));\n        }\n    }\n    return new Matrix(n, n, L);\n}\n\n\n//# sourceURL=webpack://dkk/./js_src/math/polytope.js?");

/***/ }),

/***/ "./js_src/math/routes.js":
/*!*******************************!*\
  !*** ./js_src/math/routes.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DAGCliques = exports.Clique = void 0;\nvar result_1 = __webpack_require__(/*! ../util/result */ \"./js_src/util/result.js\");\nvar hasse_1 = __webpack_require__(/*! ./hasse */ \"./js_src/math/hasse.js\");\nvar Route = /** @class */ (function () {\n    function Route(edges) {\n        this.edges = edges;\n    }\n    return Route;\n}());\nvar Clique = /** @class */ (function () {\n    function Clique(routes) {\n        this.routes = routes;\n    }\n    Clique.indexed_local_edge_order = function (edge_num, routes, dag_context) {\n        return function (a, b) {\n            var r1 = routes[a];\n            var r2 = routes[b];\n            var ssr = dag_context.shared_subroutes(r1, r2);\n            for (var _i = 0, ssr_1 = ssr; _i < ssr_1.length; _i++) {\n                var shared = ssr_1[_i];\n                if (shared.edges.includes(edge_num)) {\n                    if (shared.in_order == 0)\n                        return shared.out_order;\n                    return shared.in_order;\n                }\n            }\n            return 1;\n        };\n    };\n    Clique.build_with_order = function (routes, dag_context) {\n        var routes_per_edge = [];\n        for (var edge_num = 0; edge_num < dag_context.dag.num_edges(); edge_num++) {\n            var routes_on_edge = [];\n            for (var i = 0; i < routes.length; i++) {\n                var r = routes[i];\n                var route = dag_context.routes[r];\n                if (route.edges.includes(edge_num))\n                    routes_on_edge.push(i);\n            }\n            var sort = Clique.indexed_local_edge_order(edge_num, routes, dag_context);\n            routes_on_edge.sort(sort);\n            routes_per_edge.push(routes_on_edge);\n        }\n        var source_edges = dag_context.dag.get_out_edges(dag_context.dag.source().unwrap()).unwrap();\n        var new_routes = [];\n        for (var _i = 0, source_edges_1 = source_edges; _i < source_edges_1.length; _i++) {\n            var edge = source_edges_1[_i];\n            for (var _a = 0, _b = routes_per_edge[edge]; _a < _b.length; _a++) {\n                var route_idx = _b[_a];\n                new_routes.push(routes[route_idx]);\n            }\n        }\n        return new Clique(new_routes);\n    };\n    return Clique;\n}());\nexports.Clique = Clique;\nvar SharedSubrouteCollection = /** @class */ (function () {\n    function SharedSubrouteCollection(subroutes) {\n        this.subroutes = subroutes;\n    }\n    return SharedSubrouteCollection;\n}());\nvar DAGCliques = /** @class */ (function () {\n    function DAGCliques(dag) {\n        var _this = this;\n        this.dag = dag;\n        var sink = dag.sink().expect(\"No unique sink!\");\n        var source = dag.source().expect(\"No unique source!\");\n        //Compute routes\n        var routes = [];\n        var incomplete_routes = [];\n        for (var _i = 0, _a = dag.get_out_edges(source).unwrap_or([]); _i < _a.length; _i++) {\n            var e = _a[_i];\n            incomplete_routes.push([e]);\n        }\n        while (incomplete_routes.length != 0) {\n            var new_paths = [];\n            for (var _b = 0, incomplete_routes_1 = incomplete_routes; _b < incomplete_routes_1.length; _b++) {\n                var pth = incomplete_routes_1[_b];\n                var edge = dag.get_edge(pth[pth.length - 1]).unwrap();\n                if (edge.end == sink) {\n                    routes.push(new Route(pth));\n                }\n                else {\n                    for (var _c = 0, _d = dag.get_out_edges(edge.end).unwrap_or([]); _c < _d.length; _c++) {\n                        var next_edge = _d[_c];\n                        new_paths.push(__spreadArray(__spreadArray([], pth, true), [next_edge], false));\n                    }\n                }\n            }\n            incomplete_routes = new_paths;\n        }\n        this.routes = routes;\n        //Compute shared subroutes\n        var shared_subroutes_arr = [];\n        for (var i = 0; i < routes.length; i++) {\n            shared_subroutes_arr.push([]);\n            for (var j = 0; j < routes.length; j++) {\n                shared_subroutes_arr[i].push(new SharedSubrouteCollection(this.inner_shared_subroutes(i, j)));\n            }\n        }\n        this.shared_subroutes_arr = shared_subroutes_arr;\n        //Compute cliques\n        var extend = function (arr) {\n            var start = Math.max.apply(null, arr) + 1;\n            var out = [];\n            for (var j = start; j < _this.routes.length; j++) {\n                var compat = true;\n                for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {\n                    var e = arr_1[_i];\n                    if (!_this.inner_compatible(e, j)) {\n                        compat = false;\n                        break;\n                    }\n                }\n                if (compat)\n                    out.push(__spreadArray(__spreadArray([], arr, true), [j], false));\n            }\n            return out;\n        };\n        var cliques = [];\n        var nonmaximal = [];\n        for (var i = 0; i < this.routes.length; i++) {\n            nonmaximal.push([i]);\n        }\n        while (true) {\n            var new_nm = [];\n            for (var _e = 0, nonmaximal_1 = nonmaximal; _e < nonmaximal_1.length; _e++) {\n                var base = nonmaximal_1[_e];\n                new_nm.push.apply(new_nm, extend(base));\n            }\n            if (new_nm.length == 0) {\n                for (var _f = 0, nonmaximal_2 = nonmaximal; _f < nonmaximal_2.length; _f++) {\n                    var arr = nonmaximal_2[_f];\n                    cliques.push(Clique.build_with_order(arr, this));\n                }\n                break;\n            }\n            else {\n                nonmaximal = new_nm;\n            }\n        }\n        this.cliques = cliques;\n        this.clique_size = cliques[0].routes.length;\n        //Computes the result of trying to 'swap' a given\n        //route\n        var clique_route_swaps = [];\n        for (var i = 0; i < this.cliques.length; i++) {\n            clique_route_swaps.push([]);\n            for (var j = 0; j < this.clique_size; j++) {\n                clique_route_swaps[i].push(i);\n            }\n        }\n        for (var clq1 = 0; clq1 < this.cliques.length; clq1++) {\n            var _loop_1 = function (clq2) {\n                var c1 = this_1.cliques[clq1];\n                var c2 = this_1.cliques[clq2];\n                var intersection = c1.routes.filter(function (value) { return c2.routes.includes(value); });\n                if (intersection.length != c1.routes.length - 1)\n                    return \"continue\";\n                var i_r1 = -1;\n                for (var _g = 0, _h = c1.routes; _g < _h.length; _g++) {\n                    var r1 = _h[_g];\n                    if (!c2.routes.includes(r1))\n                        i_r1 = c1.routes.indexOf(r1);\n                }\n                var i_r2 = -1;\n                for (var _j = 0, _k = c2.routes; _j < _k.length; _j++) {\n                    var r2 = _k[_j];\n                    if (!c1.routes.includes(r2))\n                        i_r2 = c2.routes.indexOf(r2);\n                }\n                clique_route_swaps[clq1][i_r1] = clq2;\n                clique_route_swaps[clq2][i_r2] = clq1;\n            };\n            var this_1 = this;\n            for (var clq2 = clq1 + 1; clq2 < this.cliques.length; clq2++) {\n                _loop_1(clq2);\n            }\n        }\n        this.route_swaps = clique_route_swaps;\n        //Computes the poset relation\n        var clique_leq_matrix = [];\n        for (var clq1 = 0; clq1 < this.cliques.length; clq1++) {\n            clique_leq_matrix.push([]);\n            for (var clq2 = 0; clq2 < this.cliques.length; clq2++) {\n                clique_leq_matrix[clq1].push(this.inner_clique_leq(clq1, clq2));\n            }\n        }\n        this.clique_leq_matrix = clique_leq_matrix;\n        this.hasse = new hasse_1.HasseDiagram(clique_leq_matrix, this.cliques);\n    }\n    /*\n    These 'inner' functions are used during the constructor to compute data\n    that is then stored to be read later. There is no need to call them anywhere\n    besides the constructor.\n    Be careful when editing! These do should not assume the object is fully constructed.\n    */\n    //Computes shared subroutes between two routes\n    //Only assumes this.dag and this.routes have been initialized.\n    DAGCliques.prototype.inner_shared_subroutes = function (route_idx_1, route_idx_2) {\n        var r1_e = this.routes[route_idx_1].edges;\n        var r2_e = this.routes[route_idx_2].edges;\n        var r1_v = this.inner_route_vertices(route_idx_1);\n        var r2_v = this.inner_route_vertices(route_idx_2);\n        var shared_subsequences = [];\n        for (var i = 0; i < r1_v.length; i++) {\n            var vert = r1_v[i];\n            if (!r2_v.includes(vert))\n                continue;\n            var j = r2_v.indexOf(vert);\n            var start1 = i;\n            var start2 = j;\n            var edges = [];\n            //Reuse of 'i' here is not a mistake\n            while (i < r1_e.length &&\n                j < r2_e.length &&\n                r1_e[i] == r2_e[j]) {\n                edges.push(r1_e[i]);\n                i += 1;\n                j += 1;\n            }\n            var end1 = i;\n            var end2 = j;\n            var in_edges = result_1.Option.none();\n            var out_edges = result_1.Option.none();\n            var in_order = 0;\n            var out_order = 0;\n            if (start1 != 0) {\n                var edge1 = r1_e[start1 - 1];\n                var edge2 = r2_e[start2 - 1];\n                in_edges = result_1.Option.some([edge1, edge2]);\n                var in_edge_list = this.dag.get_in_edges(vert).unwrap();\n                var pos1 = in_edge_list.indexOf(edge1);\n                var pos2 = in_edge_list.indexOf(edge2);\n                if (pos1 > pos2)\n                    in_order = 1;\n                else\n                    in_order = -1;\n            }\n            if (end1 < r1_e.length) {\n                var edge1 = r1_e[end1];\n                var edge2 = r2_e[end2];\n                out_edges = result_1.Option.some([edge1, edge2]);\n                var vert_1 = r1_v[end1];\n                var out_edge_list = this.dag.get_out_edges(vert_1).unwrap();\n                var pos1 = out_edge_list.indexOf(edge1);\n                var pos2 = out_edge_list.indexOf(edge2);\n                if (pos1 > pos2)\n                    out_order = 1;\n                else\n                    out_order = -1;\n            }\n            var shared = {\n                in_vert: r1_v[start1],\n                out_vert: r1_v[i - 1],\n                in_edges: in_edges,\n                out_edges: out_edges,\n                in_order: in_order,\n                out_order: out_order,\n                edges: edges\n            };\n            shared_subsequences.push(shared);\n        }\n        return shared_subsequences;\n    };\n    //Computes poset relation\n    //Only assumes this.dag, this.routes, and this.cliques have been initialized.\n    DAGCliques.prototype.inner_clique_leq = function (clq_idx_1, clq_idx_2) {\n        if (clq_idx_1 == clq_idx_2)\n            return true;\n        var c1 = this.cliques[clq_idx_1];\n        var c2 = this.cliques[clq_idx_2];\n        for (var _i = 0, _a = c1.routes; _i < _a.length; _i++) {\n            var r1 = _a[_i];\n            for (var _b = 0, _c = c2.routes; _b < _c.length; _b++) {\n                var r2 = _c[_b];\n                if (this.inner_up_incompatible(r1, r2))\n                    return false;\n            }\n        }\n        return true;\n    };\n    //Computes compatibility between two routes.\n    //Only assumes this.dag and this.routes have been initialized.\n    DAGCliques.prototype.inner_compatible = function (route_idx_1, route_idx_2) {\n        var shared_subroutes = this.shared_subroutes(route_idx_1, route_idx_2);\n        for (var _i = 0, shared_subroutes_1 = shared_subroutes; _i < shared_subroutes_1.length; _i++) {\n            var sub = shared_subroutes_1[_i];\n            if (sub.in_order * sub.out_order < -0.01)\n                return false;\n        }\n        return true;\n    };\n    //Computes up-compatibility between two routes.\n    //Only assumes this.dag and this.routes have been initialized.\n    DAGCliques.prototype.inner_up_incompatible = function (route_idx_1, route_idx_2) {\n        var shared_subroutes = this.shared_subroutes(route_idx_1, route_idx_2);\n        for (var _i = 0, shared_subroutes_2 = shared_subroutes; _i < shared_subroutes_2.length; _i++) {\n            var sub = shared_subroutes_2[_i];\n            if (sub.in_order > 0 && sub.out_order < 0) {\n                return true;\n            }\n        }\n        return false;\n    };\n    //Computes vertices of route\n    //Only assumes this.dag and this.routes have been initialized.\n    DAGCliques.prototype.inner_route_vertices = function (route_idx) {\n        var out = [this.dag.get_edge(this.routes[route_idx].edges[0]).unwrap().start];\n        for (var _i = 0, _a = this.routes[route_idx].edges; _i < _a.length; _i++) {\n            var edge_idx = _a[_i];\n            out.push(this.dag.get_edge(edge_idx).unwrap().end);\n        }\n        return out;\n    };\n    //Normal methods\n    /*\n    These mostly access data computed in the constructor, with names\n    of function arguments that are a tad more suggestive than just\n    blindly indexing into a list.\n    */\n    DAGCliques.prototype.clique_leq = function (clq_idx_1, clq_idx_2) {\n        return this.clique_leq_matrix[clq_idx_1][clq_idx_2];\n    };\n    DAGCliques.prototype.shared_subroutes = function (route_idx_1, route_idx_2) {\n        return this.shared_subroutes_arr[route_idx_1][route_idx_2].subroutes;\n    };\n    DAGCliques.prototype.routes_at = function (edge_num, clique_num) {\n        var out = [];\n        var clique = this.cliques[clique_num];\n        for (var i = 0; i < clique.routes.length; i++) {\n            var r = clique.routes[i];\n            var route = this.routes[r];\n            if (route.edges.includes(edge_num))\n                out.push(r);\n        }\n        return out;\n    };\n    DAGCliques.prototype.route_swap_by_route_idx = function (clique_idx, route_idx) {\n        var clq = this.cliques[clique_idx];\n        for (var i = 0; i < clq.routes.length; i++) {\n            if (clq.routes[i] == route_idx) {\n                return this.route_swaps[clique_idx][i];\n            }\n        }\n        console.warn(\"Just tried to swap route not present in given clique.\");\n        return clique_idx;\n    };\n    DAGCliques.prototype.route_swap_by_idx_in_clq = function (clique_idx, idx_in_clique) {\n        return this.route_swaps[clique_idx][idx_in_clique];\n    };\n    return DAGCliques;\n}());\nexports.DAGCliques = DAGCliques;\n\n\n//# sourceURL=webpack://dkk/./js_src/math/routes.js?");

/***/ }),

/***/ "./js_src/modes/clique_viewer.js":
/*!***************************************!*\
  !*** ./js_src/modes/clique_viewer.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CliqueViewer = void 0;\nvar dag_canvas_1 = __webpack_require__(/*! ../subelements/dag_canvas */ \"./js_src/subelements/dag_canvas.js\");\nvar html_elems_1 = __webpack_require__(/*! ../html_elems */ \"./js_src/html_elems.js\");\nvar num_1 = __webpack_require__(/*! ../util/num */ \"./js_src/util/num.js\");\nvar draw_option_box_1 = __webpack_require__(/*! ../subelements/draw_option_box */ \"./js_src/subelements/draw_option_box.js\");\nvar routes_1 = __webpack_require__(/*! ../math/routes */ \"./js_src/math/routes.js\");\nvar swap_box_1 = __webpack_require__(/*! ../subelements/swap_box */ \"./js_src/subelements/swap_box.js\");\nvar polytope_1 = __webpack_require__(/*! ../math/polytope */ \"./js_src/math/polytope.js\");\nvar polytope_canvas_1 = __webpack_require__(/*! ../subelements/polytope_canvas */ \"./js_src/subelements/polytope_canvas.js\");\nvar CliqueViewer = /** @class */ (function () {\n    function CliqueViewer(dag, draw_options, sidebar_head, sidebar_contents, right_area) {\n        var _this = this;\n        this.current_clique = 0;\n        this.dag = dag;\n        this.draw_options = draw_options;\n        this.cliques = new routes_1.DAGCliques(dag.dag);\n        this.polytope = new polytope_1.FlowPolytope(this.cliques);\n        this.draw_options.set_builtin_color_scheme(this.cliques.routes.length);\n        draw_options.add_change_listener(function () {\n            if (_this) {\n                var nc = _this.cliques.cliques[_this.current_clique];\n                _this.poly_canvas.set_clique(nc);\n                _this.draw();\n            }\n            if (_this.swap_box)\n                _this.swap_box.update_color();\n        });\n        //sidebar\n        sidebar_head.innerText = \"Clique Viewer\";\n        //Settings box\n        var _a = draw_option_box_1.DrawOptionBox.create(draw_options), box = _a.box, box_element = _a.element;\n        sidebar_contents.appendChild(box_element);\n        this.draw_options_box = box;\n        //Swap box\n        var _b = swap_box_1.SwapBox.create(function (idx) {\n            _this.route_swap(idx);\n        }, draw_options, this.cliques.clique_size), swap_box = _b.box, swap_box_element = _b.element;\n        sidebar_contents.appendChild(swap_box_element);\n        this.swap_box = swap_box;\n        //Right area dividers\n        var segments = build_right_area_zones();\n        right_area.appendChild(segments.root);\n        //Resize\n        if (this.polytope.dim > 3) {\n            segments.poly.className = \"clq-minify\";\n        }\n        //Graph Canvas\n        var _c = dag_canvas_1.DAGCanvas.create(draw_options), clique_canvas = _c.canvas, c_canvas_element = _c.element;\n        segments.clique.appendChild(c_canvas_element);\n        c_canvas_element.addEventListener(\"click\", function (ev) {\n            _this.clique_canvas_click(new num_1.Vector2(ev.layerX, ev.layerY));\n        });\n        clique_canvas.resize_canvas();\n        this.clique_canvas = clique_canvas;\n        //Hasse Canvas\n        var _d = dag_canvas_1.DAGCanvas.create(draw_options), hasse_canvas = _d.canvas, h_canvas_element = _d.element;\n        segments.hasse.appendChild(h_canvas_element);\n        hasse_canvas.resize_canvas();\n        this.hasse_canvas = hasse_canvas;\n        //Polytope canvas\n        var _e = polytope_canvas_1.PolytopeCanvas.create(draw_options), poly_canvas = _e.canvas, p_canvas_element = _e.element;\n        segments.poly.appendChild(p_canvas_element);\n        poly_canvas.resize_canvas();\n        poly_canvas.set_polytope(this.polytope, this.cliques.cliques[this.current_clique]);\n        this.poly_canvas = poly_canvas;\n        //Draw and setup redraw\n        this.resize_event = function (event) {\n            _this.clique_canvas.resize_canvas();\n            _this.hasse_canvas.resize_canvas();\n            _this.poly_canvas.resize_canvas();\n            _this.draw();\n        };\n        this.draw();\n        addEventListener(\"resize\", this.resize_event);\n        var cc = this.cliques.cliques[this.current_clique];\n        for (var i = 0; i < cc.routes.length; i++) {\n            this.swap_box.set_color(i, cc.routes[i]);\n        }\n        this.update_route_enabled();\n    }\n    CliqueViewer.prototype.name = function () {\n        return \"clique-viewer\";\n    };\n    CliqueViewer.prototype.current_embedding = function () {\n        return this.dag;\n    };\n    CliqueViewer.prototype.current_data_json = function () {\n        return this.dag.to_json();\n    };\n    CliqueViewer.destructive_new = function (dag, draw_options) {\n        html_elems_1.SIDEBAR_HEAD.innerHTML = \"\";\n        html_elems_1.SIDEBAR_CONTENTS.innerHTML = \"\";\n        html_elems_1.RIGHT_AREA.innerHTML = \"\";\n        return new CliqueViewer(dag, draw_options, html_elems_1.SIDEBAR_HEAD, html_elems_1.SIDEBAR_CONTENTS, html_elems_1.RIGHT_AREA);\n    };\n    CliqueViewer.dummy_new = function (dag, draw_options) {\n        var get_dummy = function () { return document.createElement(\"div\"); };\n        return new CliqueViewer(dag, draw_options, get_dummy(), get_dummy(), get_dummy());\n    };\n    CliqueViewer.prototype.clear_global_events = function () {\n        removeEventListener(\"resize\", this.resize_event);\n    };\n    CliqueViewer.prototype.clique_canvas_click = function (position) {\n        this.draw_clique();\n    };\n    CliqueViewer.prototype.route_swap = function (idx) {\n        var old_clq = this.current_clique;\n        var new_clq = this.cliques.route_swap_by_route_idx(this.current_clique, idx);\n        this.current_clique = new_clq;\n        var oc = this.cliques.cliques[old_clq];\n        var nc = this.cliques.cliques[new_clq];\n        this.poly_canvas.set_clique(nc);\n        if (old_clq != new_clq) {\n            var old_route = -1;\n            for (var _i = 0, _a = oc.routes; _i < _a.length; _i++) {\n                var r = _a[_i];\n                if (!nc.routes.includes(r)) {\n                    old_route = r;\n                    break;\n                }\n            }\n            var new_route = -1;\n            for (var _b = 0, _c = nc.routes; _b < _c.length; _b++) {\n                var r = _c[_b];\n                if (!oc.routes.includes(r)) {\n                    new_route = r;\n                    break;\n                }\n            }\n            if (old_route !== -1 && new_route !== -1)\n                this.swap_box.swap_color(old_route, new_route);\n            else\n                console.warn(\"Old route and new clique do not differ as expected.\");\n            this.update_route_enabled();\n        }\n        this.draw();\n    };\n    CliqueViewer.prototype.update_route_enabled = function () {\n        var nc = this.cliques.cliques[this.current_clique];\n        for (var _i = 0, _a = nc.routes; _i < _a.length; _i++) {\n            var r = _a[_i];\n            var en = this.cliques.route_swap_by_route_idx(this.current_clique, r) != this.current_clique;\n            this.swap_box.show_enabled(r, en);\n        }\n    };\n    /*\n    Code for drawing\n    */\n    CliqueViewer.prototype.draw = function () {\n        this.draw_clique();\n        this.draw_hasse();\n        this.draw_polytope();\n        this.swap_box.update_color();\n    };\n    CliqueViewer.prototype.draw_clique = function () {\n        var ctx = this.clique_canvas.get_ctx();\n        var data = this.dag.bake();\n        ctx.clear();\n        for (var edge_idx = 0; edge_idx < data.edges.length; edge_idx++) {\n            var edge = data.edges[edge_idx];\n            var orthog = edge.end_point\n                .sub(edge.start_point)\n                .rot90()\n                .normalized();\n            ctx.draw_bez(edge, this.draw_options.edge_color() + \"22\", this.draw_options.edge_weight(), false);\n            //routes\n            var routes = this.cliques.routes_at(edge_idx, this.current_clique);\n            if (routes.length == 0)\n                continue;\n            var full_width = this.draw_options.route_weight() * Math.pow(routes.length, 0.8);\n            var width = full_width / routes.length * 1.01;\n            var _loop_1 = function (i) {\n                var r = routes[i];\n                var color = this_1.draw_options.get_route_color(r);\n                var offset = num_1.Vector2.zero();\n                if (routes.length > 1) {\n                    var percent = i / (routes.length - 1) - 0.5;\n                    offset = orthog.scale(percent * (full_width - width) / this_1.draw_options.scale());\n                }\n                ctx.draw_bez(edge.transform(function (v) { return v.add(offset); }), color, width, false);\n            };\n            var this_1 = this;\n            for (var i = 0; i < routes.length; i++) {\n                _loop_1(i);\n            }\n        }\n        if (this.draw_options.label_framing())\n            ctx.decorate_edges_num(this.dag.dag, data);\n        for (var _i = 0, _a = data.verts; _i < _a.length; _i++) {\n            var vert = _a[_i];\n            ctx.draw_node(vert);\n        }\n    };\n    CliqueViewer.prototype.draw_hasse = function () {\n        var ctx = this.hasse_canvas.get_ctx();\n        ctx.clear();\n        var PADDING = 100; //TODO: make parameter\n        var v_width = Math.max(1, this.hasse_canvas.width() - 2 * PADDING);\n        var v_height = Math.max(1, this.hasse_canvas.height() - 2 * PADDING);\n        var hasse = this.cliques.hasse;\n        var hasse_ext = hasse.bounding_box.extent().scale(2);\n        var w_scale = v_width / hasse_ext.x;\n        var h_scale = v_height / hasse_ext.y;\n        var scale = Math.min(w_scale, h_scale) / this.draw_options.scale();\n        var positions = hasse.layout_rows\n            .map(function (v) { return v.scale(scale); });\n        for (var i = 0; i < hasse.covering_relation.length; i++)\n            for (var j = 0; j < hasse.covering_relation.length; j++) {\n                if (hasse.covering_relation[i][j]) {\n                    var mid = positions[i].add(positions[j]).scale(0.5);\n                    var rts = hasse.cover_routes[i][j];\n                    var color1 = this.draw_options.get_route_color(rts[0]);\n                    var color2 = this.draw_options.get_route_color(rts[1]);\n                    ctx.draw_line(positions[i], mid, color1, this.draw_options.hasse_edge_weight());\n                    ctx.draw_line(mid, positions[j], color2, this.draw_options.hasse_edge_weight());\n                }\n            }\n        if (!this.draw_options.hasse_show_cliques()) {\n            for (var i = 0; i < positions.length; i++) {\n                var color = this.draw_options.hasse_node_color();\n                if (this.current_clique == i)\n                    color = this.draw_options.hasse_current_node_color();\n                var pos = positions[i];\n                ctx.draw_circ(pos, color, this.draw_options.hasse_node_size());\n            }\n        }\n        else {\n            var data = this.dag.bake();\n            for (var i = 0; i < positions.length; i++) {\n                var pos = positions[i];\n                this.draw_mini_clique(pos, i, data, ctx);\n            }\n        }\n    };\n    CliqueViewer.prototype.draw_polytope = function () {\n        this.poly_canvas.draw();\n    };\n    CliqueViewer.prototype.draw_mini_clique = function (center, clique_idx, data, ctx) {\n        var rad = 1.0;\n        for (var _i = 0, _a = data.verts; _i < _a.length; _i++) {\n            var p = _a[_i];\n            rad = Math.max(p.norm(), rad);\n        }\n        var scale = this.draw_options.hasse_mini_dag_size() / (rad * this.draw_options.scale());\n        var box = new num_1.BoundingBox([]);\n        for (var edge_idx = 0; edge_idx < data.edges.length; edge_idx++) {\n            var edge = data.edges[edge_idx].transform(function (v) { return v.scale(scale).add(center); });\n            box.add_point(edge.start_point);\n            box.add_point(edge.cp1);\n            box.add_point(edge.cp2);\n            box.add_point(edge.end_point);\n        }\n        box.pad(1.0 * this.draw_options.hasse_mini_vert_rad() / this.draw_options.scale());\n        ctx.draw_box(box.top_corner, box.bot_corner, this.draw_options.background_color());\n        if (clique_idx == this.current_clique) {\n            ctx.draw_rounded_box(box.top_corner, box.bot_corner, 10, this.draw_options.hasse_current_color());\n        }\n        for (var edge_idx = 0; edge_idx < data.edges.length; edge_idx++) {\n            var edge = data.edges[edge_idx].transform(function (v) { return v.scale(scale).add(center); });\n            var orthog = edge.end_point\n                .sub(edge.start_point)\n                .rot90()\n                .normalized();\n            var routes = this.cliques.routes_at(edge_idx, clique_idx);\n            if (routes.length == 0)\n                continue;\n            var full_width = this.draw_options.hasse_mini_route_weight() * Math.pow(routes.length, 0.8);\n            var width = full_width / routes.length * 1.01;\n            var _loop_2 = function (i) {\n                var r = routes[i];\n                var color = this_2.draw_options.get_route_color(r);\n                var offset = num_1.Vector2.zero();\n                if (routes.length > 1) {\n                    var percent = i / (routes.length - 1) - 0.5;\n                    offset = orthog.scale(percent * (full_width - width) / this_2.draw_options.scale());\n                }\n                ctx.draw_bez(edge.transform(function (v) { return v.add(offset); }), color, width, false);\n            };\n            var this_2 = this;\n            for (var i = 0; i < routes.length; i++) {\n                _loop_2(i);\n            }\n        }\n        for (var _b = 0, _c = data.verts; _b < _c.length; _b++) {\n            var pos = _c[_b];\n            ctx.draw_circ(pos.scale(scale).add(center), this.draw_options.vertex_color(), this.draw_options.hasse_mini_vert_rad());\n        }\n    };\n    return CliqueViewer;\n}());\nexports.CliqueViewer = CliqueViewer;\nfunction build_right_area_zones() {\n    var root = document.createElement(\"div\");\n    root.id = \"clq-root\";\n    var lft = document.createElement(\"div\");\n    var right = document.createElement(\"div\");\n    root.appendChild(lft);\n    root.appendChild(right);\n    var top = document.createElement(\"div\");\n    var bot = document.createElement(\"div\");\n    lft.appendChild(top);\n    lft.appendChild(bot);\n    return { root: root, poly: bot, hasse: right, clique: top };\n}\n\n\n//# sourceURL=webpack://dkk/./js_src/modes/clique_viewer.js?");

/***/ }),

/***/ "./js_src/modes/embedding_editor.js":
/*!******************************************!*\
  !*** ./js_src/modes/embedding_editor.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EmbeddingEditor = void 0;\nvar dag_layout_1 = __webpack_require__(/*! ../draw/dag_layout */ \"./js_src/draw/dag_layout.js\");\nvar num_1 = __webpack_require__(/*! ../util/num */ \"./js_src/util/num.js\");\nvar result_1 = __webpack_require__(/*! ../util/result */ \"./js_src/util/result.js\");\nvar html_elems_1 = __webpack_require__(/*! ../html_elems */ \"./js_src/html_elems.js\");\nvar dag_canvas_1 = __webpack_require__(/*! ../subelements/dag_canvas */ \"./js_src/subelements/dag_canvas.js\");\nvar draw_option_box_1 = __webpack_require__(/*! ../subelements/draw_option_box */ \"./js_src/subelements/draw_option_box.js\");\nvar action_box_1 = __webpack_require__(/*! ../subelements/action_box */ \"./js_src/subelements/action_box.js\");\nvar angle_override_1 = __webpack_require__(/*! ../subelements/angle_override */ \"./js_src/subelements/angle_override.js\");\nvar editor_options_1 = __webpack_require__(/*! ../editor_options */ \"./js_src/editor_options.js\");\nvar vec_spinner_1 = __webpack_require__(/*! ../subelements/vec_spinner */ \"./js_src/subelements/vec_spinner.js\");\nvar Selection = /** @class */ (function () {\n    function Selection(type, inner) {\n        this.type = type;\n        this.inner = inner;\n    }\n    Selection.none = function () {\n        return new Selection(\"none\", null);\n    };\n    Selection.vertex = function (num) {\n        return new Selection(\"vertex\", num);\n    };\n    Selection.edge = function (num) {\n        return new Selection(\"edge\", num);\n    };\n    Selection.prototype.pair_of = function (single) {\n        return (this.type == \"pair_verts\" && single == \"vertex\") ||\n            (this.type == \"pair_edges\" && single == \"edge\");\n    };\n    Selection.prototype.single = function () {\n        return this.type == \"vertex\" || this.type == \"edge\";\n    };\n    Selection.prototype.pair = function () {\n        return this.type == \"pair_verts\" || this.type == \"pair_edges\";\n    };\n    Selection.prototype.change = function (clicked, index, shift_held) {\n        if (this.type == \"none\" ||\n            !shift_held ||\n            (this.single() && this.type != clicked) ||\n            (this.pair() && !this.pair_of(clicked))) {\n            return new Selection(clicked, index);\n        }\n        //Some of these conditions are redundant,\n        //but they make it more explicit what is going on\n        if (shift_held && this.single() && this.type == clicked) {\n            var pair = [this.inner, index];\n            if (this.type == \"vertex\") {\n                if (pair[0] != pair[1])\n                    return new Selection(\"pair_verts\", pair);\n                else\n                    return new Selection(\"vertex\", pair[0]);\n            }\n            else if (this.type == \"edge\") {\n                if (pair[0] != pair[1])\n                    return new Selection(\"pair_edges\", pair);\n                else\n                    return new Selection(\"edge\", pair[0]);\n            }\n            else {\n                throw new Error(\"This branch should be impossible.\");\n            }\n        }\n        if (shift_held && this.pair() && this.pair_of(clicked)) {\n            var pair = [this.inner[1], index];\n            if (this.type == \"pair_verts\") {\n                if (pair[0] != pair[1])\n                    return new Selection(\"pair_verts\", pair);\n                else\n                    return new Selection(\"vertex\", pair[0]);\n            }\n            else if (this.type == \"pair_edges\") {\n                if (pair[0] != pair[1])\n                    return new Selection(\"pair_edges\", pair);\n                else\n                    return new Selection(\"edge\", pair[0]);\n            }\n            else {\n                throw new Error(\"This branch should be impossible.\");\n            }\n        }\n        throw new Error(\"This branch should be impossible.\");\n    };\n    return Selection;\n}());\nvar EmbeddingEditor = /** @class */ (function () {\n    function EmbeddingEditor(dag, draw_options, sidebar_head, sidebar_contents, right_area) {\n        var _this = this;\n        this.editor_options = new editor_options_1.EditorOptions();\n        this.selected = Selection.none();\n        this.e_drag = {\n            dragging: false,\n            vert: 0\n        };\n        this.v_drag = {\n            dragging: false,\n            vert: 0\n        };\n        this.h_drag = {\n            dragging: false,\n            edge: 0,\n            side: \"start\"\n        };\n        this.mouse_pos = num_1.Vector2.zero();\n        this.embedding = dag;\n        this.draw_options = draw_options;\n        draw_options.add_change_listener(function () { return _this.draw(); });\n        sidebar_head.innerText = \"Embedding Editor\";\n        var _a = draw_option_box_1.DrawOptionBox.create(draw_options), do_box = _a.box, do_box_element = _a.element;\n        sidebar_contents.appendChild(do_box_element);\n        this.draw_options_box = do_box;\n        this.error_box = document.createElement(\"div\");\n        this.error_box.id = \"ee-error-zone\";\n        sidebar_contents.appendChild(this.error_box);\n        var _b = action_box_1.ActionBox.create(), dag_box = _b.box, dag_element = _b.element;\n        sidebar_contents.appendChild(dag_element);\n        dag_box.add_title(\"DAG Edit\");\n        this.add_edge_button = dag_box.add_button(\"Add edge\", function () { return _this.add_edge_selected(); });\n        this.remove_edge_button = dag_box.add_button(\"Remove edge\", function () { return _this.remove_edge_selected(); });\n        this.swap_start_button = dag_box.add_button(\"Swap framing at start\", function () { return _this.swap_at_start_selected(); });\n        this.swap_end_button = dag_box.add_button(\"Swap framing at end\", function () { return _this.swap_at_end_selected(); });\n        this.add_reembed_cb = dag_box.add_checkbox(\"Re-embed on add\", function (v) { return _this.editor_options.set_reembed_add(v); });\n        this.add_reembed_cb.checked = this.editor_options.reembed_add();\n        this.remove_reembed_cb = dag_box.add_checkbox(\"Re-embed on remove\", function (v) { return _this.editor_options.set_reembed_remove(v); });\n        this.remove_reembed_cb.checked = this.editor_options.reembed_remove();\n        this.swap_reembed_cb = dag_box.add_checkbox(\"Re-embed on swap\", function (v) { return _this.editor_options.set_reembed_swap(v); });\n        this.swap_reembed_cb.checked = this.editor_options.reembed_swap();\n        dag_box.add_shortcut_popup([\n            [\"Add edge\", \"E\"],\n            [\"Remove edge\", \"Backspace\"],\n            [\"Swap framing at start\", \"D\"],\n            [\"Swap framing at end\", \"Shift+D\"]\n        ]);\n        var _c = action_box_1.ActionBox.create(), emb_box = _c.box, emb_element = _c.element;\n        sidebar_contents.appendChild(emb_element);\n        emb_box.add_title(\"Embedding Edit\");\n        emb_box.add_tip(\"Ctrl+Drag to move vertices.\");\n        emb_box.add_space(12);\n        var _d = emb_box.add_dual_spinner(\"In-spread\", \"emb-in-spread\", [15, 180], 5, function (val) { return _this.set_in_angle_selected(val * (Math.PI / 180)); }, \"Out-spread\", \"emb-out-spread\", [15, 180], 5, function (val) { return _this.set_out_angle_selected(val * (Math.PI / 180)); }), inout_row = _d.row, in_spinner = _d.spinner1, out_spinner = _d.spinner2;\n        this.inout = inout_row;\n        this.in_spread_spinner = in_spinner;\n        this.out_spread_spinner = out_spinner;\n        this.vert_pos_spinner = new vec_spinner_1.VecSpinner();\n        this.vps_row = emb_box.add_labelled_row(this.vert_pos_spinner.base, \"Position\");\n        this.vert_pos_spinner.add_change_listeners(function (v) {\n            if (_this.selected.type == \"vertex\") {\n                var vert = _this.selected.inner;\n                _this.embedding.vert_data[vert].position = v;\n                _this.draw();\n            }\n        });\n        this.start_angle_override = new angle_override_1.AngleOverrideController(\"Start\");\n        this.start_angle_override.add_change_listeners(function (ov) { return _this.change_start_override_selected(ov); });\n        emb_box.add_row(this.start_angle_override.base);\n        this.end_angle_override = new angle_override_1.AngleOverrideController(\"End\");\n        this.end_angle_override.add_change_listeners(function (ov) { return _this.change_end_override_selected(ov); });\n        emb_box.add_row(this.end_angle_override.base);\n        emb_box.add_space(12);\n        emb_box.add_button(\"Reset to default\", function () {\n            _this.embedding.default_layout();\n            _this.draw();\n        });\n        emb_box.add_shortcut_popup([\n            [\"Move vertex\", \"Ctrl+Drag\"],\n            [\"Select two\", \"Shift+Left Click\"],\n            [\"Increase in-spread\", \"W\"],\n            [\"Decrease in-spread\", \"S\"],\n            [\"Increase out-spread\", \"Shift+W\"],\n            [\"Decrease out-spread\", \"Shift+S\"],\n        ]);\n        var _e = dag_canvas_1.DAGCanvas.create(draw_options), canvas = _e.canvas, can_element = _e.element;\n        right_area.appendChild(can_element);\n        can_element.addEventListener(\"mousedown\", function (ev) {\n            var pos = new num_1.Vector2(ev.layerX, ev.layerY);\n            if (ev.button == 0 && !ev.ctrlKey && !ev.shiftKey) {\n                _this.try_handle_drag_start(pos);\n                if (!_this.h_drag.dragging)\n                    _this.try_edge_drag_start(pos);\n            }\n            if (ev.button == 0 && ev.ctrlKey && !ev.shiftKey)\n                _this.try_vert_drag_start(pos);\n        });\n        can_element.addEventListener(\"mouseup\", function (ev) {\n            if (ev.button == 0) {\n                _this.edge_drag_end(new num_1.Vector2(ev.layerX, ev.layerY));\n                _this.vert_drag_end();\n                var skip_click = _this.handle_drag_end();\n                if (!skip_click)\n                    _this.canvas_click(new num_1.Vector2(ev.layerX, ev.layerY), ev.shiftKey);\n                _this.draw();\n            }\n        });\n        can_element.addEventListener(\"mouseleave\", function (ev) {\n            _this.edge_drag_end(new num_1.Vector2(ev.layerX, ev.layerY));\n            _this.vert_drag_end();\n            _this.handle_drag_end();\n            _this.draw();\n        });\n        can_element.addEventListener(\"mousemove\", function (ev) {\n            _this.mouse_pos = new num_1.Vector2(ev.layerX, ev.layerY);\n            _this.move_dragged_vert();\n            _this.move_dragged_handle();\n            if (_this.e_drag.dragging || _this.v_drag.dragging || _this.h_drag.dragging)\n                _this.draw();\n        });\n        canvas.resize_canvas();\n        this.canvas = canvas;\n        this.draw();\n        this.resize_event = function (event) {\n            _this.canvas.resize_canvas();\n            _this.draw();\n        };\n        this.keydown_event = function (ev) { return _this.handle_keypress(ev); };\n        addEventListener(\"resize\", this.resize_event);\n        addEventListener(\"keydown\", this.keydown_event);\n        this.update_sidebar();\n    }\n    EmbeddingEditor.prototype.name = function () {\n        return \"embedding-editor\";\n    };\n    EmbeddingEditor.prototype.current_embedding = function () {\n        return this.embedding;\n    };\n    EmbeddingEditor.prototype.current_data_json = function () {\n        return this.embedding.to_json();\n    };\n    EmbeddingEditor.destructive_new = function (dag, draw_options) {\n        html_elems_1.SIDEBAR_HEAD.innerHTML = \"\";\n        html_elems_1.SIDEBAR_CONTENTS.innerHTML = \"\";\n        html_elems_1.RIGHT_AREA.innerHTML = \"\";\n        return new EmbeddingEditor(dag, draw_options, html_elems_1.SIDEBAR_HEAD, html_elems_1.SIDEBAR_CONTENTS, html_elems_1.RIGHT_AREA);\n    };\n    EmbeddingEditor.dummy_new = function (dag, draw_options) {\n        var get_dummy = function () { return document.createElement(\"div\"); };\n        return new EmbeddingEditor(dag, draw_options, get_dummy(), get_dummy(), get_dummy());\n    };\n    EmbeddingEditor.prototype.clear_global_events = function () {\n        removeEventListener(\"resize\", this.resize_event);\n        removeEventListener(\"keydown\", this.keydown_event);\n    };\n    EmbeddingEditor.prototype.change_selection = function (sel) {\n        this.selected = sel;\n        this.draw();\n        this.update_sidebar();\n    };\n    EmbeddingEditor.prototype.canvas_click = function (position, shift_held) {\n        var clicked_vert = this.get_vertex_at(position);\n        var clicked_edge = this.get_edge_at(position);\n        if (clicked_vert.is_some()) {\n            this.change_selection(this.selected.change(\"vertex\", clicked_vert.unwrap(), shift_held));\n        }\n        else if (clicked_edge.is_some()) {\n            this.change_selection(this.selected.change(\"edge\", clicked_edge.unwrap(), shift_held));\n        }\n        else {\n            this.change_selection(Selection.none());\n        }\n    };\n    EmbeddingEditor.prototype.try_handle_drag_start = function (position) {\n        var clicked_handle = this.get_handle_at(position);\n        if (clicked_handle.is_some()) {\n            var handle = clicked_handle.unwrap();\n            this.h_drag = {\n                dragging: true,\n                edge: handle.edge,\n                side: handle.side\n            };\n        }\n    };\n    EmbeddingEditor.prototype.try_edge_drag_start = function (position) {\n        var v = this.get_vertex_at(position);\n        if (v.is_some()) {\n            var vert = v.unwrap();\n            this.e_drag = {\n                dragging: true,\n                vert: vert\n            };\n        }\n    };\n    EmbeddingEditor.prototype.try_vert_drag_start = function (position) {\n        var v = this.get_vertex_at(position);\n        if (v.is_some()) {\n            var vert = v.unwrap();\n            this.v_drag = {\n                dragging: true,\n                vert: vert\n            };\n        }\n    };\n    EmbeddingEditor.prototype.edge_drag_end = function (position) {\n        if (!this.e_drag.dragging)\n            return;\n        var v = this.get_vertex_at(position);\n        if (v.is_some()) {\n            var vert = v.unwrap();\n            this.add_edge(this.e_drag.vert, vert);\n        }\n        this.e_drag.dragging = false;\n    };\n    EmbeddingEditor.prototype.vert_drag_end = function () {\n        if (!this.v_drag.dragging)\n            return;\n        this.v_drag.dragging = false;\n        this.selected = Selection.vertex(this.v_drag.vert);\n    };\n    EmbeddingEditor.prototype.handle_drag_end = function () {\n        if (!this.h_drag.dragging)\n            return false;\n        this.h_drag.dragging = false;\n        this.selected = Selection.edge(this.h_drag.edge);\n        return true;\n    };\n    EmbeddingEditor.prototype.move_dragged_vert = function () {\n        if (!this.v_drag.dragging)\n            return;\n        this.embedding.vert_data[this.v_drag.vert].position =\n            this.canvas.local_trans_inv(this.mouse_pos);\n        this.update_sidebar();\n    };\n    EmbeddingEditor.prototype.move_dragged_handle = function () {\n        if (!this.h_drag.dragging)\n            return;\n        var dagspace_mp = this.canvas.local_trans_inv(this.mouse_pos);\n        var edge_idx = this.h_drag.edge;\n        var edge = this.embedding.dag.get_edge(edge_idx).unwrap();\n        if (this.h_drag.side == \"start\") {\n            var base_position = this.embedding.vert_data[edge.start].position;\n            var tangent = dagspace_mp.sub(base_position);\n            this.embedding.edge_data[edge_idx].start_ang_override = dag_layout_1.AngleOverride.vec_abs(tangent);\n        }\n        if (this.h_drag.side == \"end\") {\n            var base_position = this.embedding.vert_data[edge.end].position;\n            var tangent = base_position.sub(dagspace_mp);\n            this.embedding.edge_data[edge_idx].end_ang_override = dag_layout_1.AngleOverride.vec_abs(tangent);\n        }\n        this.update_sidebar();\n    };\n    EmbeddingEditor.prototype.add_edge_selected = function () {\n        if (this.selected.type == \"pair_verts\") {\n            var _a = this.selected.inner, start = _a[0], end = _a[1];\n            this.add_edge(start, end);\n        }\n    };\n    EmbeddingEditor.prototype.remove_edge_selected = function () {\n        if (this.selected.type == \"edge\") {\n            var start = this.selected.inner;\n            this.remove_edge(start);\n            this.change_selection(Selection.none());\n        }\n    };\n    EmbeddingEditor.prototype.swap_at_start_selected = function () {\n        if (this.selected.type == \"pair_edges\") {\n            var _a = this.selected.inner, i = _a[0], j = _a[1];\n            this.swap_at_start(i, j);\n        }\n    };\n    EmbeddingEditor.prototype.swap_at_end_selected = function () {\n        if (this.selected.type == \"pair_edges\") {\n            var _a = this.selected.inner, i = _a[0], j = _a[1];\n            this.swap_at_end(i, j);\n        }\n    };\n    EmbeddingEditor.prototype.change_out_angle_selected = function (delta) {\n        if (this.selected.type != \"vertex\")\n            return;\n        var v = this.selected.inner;\n        this.embedding.vert_data[v].spread_out =\n            (0, num_1.clamp)(this.embedding.vert_data[v].spread_out + delta, 0, Math.PI);\n        this.draw();\n    };\n    EmbeddingEditor.prototype.change_in_angle_selected = function (delta) {\n        if (this.selected.type != \"vertex\")\n            return;\n        var v = this.selected.inner;\n        this.embedding.vert_data[v].spread_in =\n            (0, num_1.clamp)(this.embedding.vert_data[v].spread_in + delta, 0, Math.PI);\n        this.draw();\n    };\n    EmbeddingEditor.prototype.change_start_override_selected = function (val) {\n        if (this.selected.type != \"edge\")\n            return;\n        var edge_idx = this.selected.inner;\n        this.embedding.edge_data[edge_idx].start_ang_override = val;\n        this.draw();\n    };\n    EmbeddingEditor.prototype.change_end_override_selected = function (val) {\n        if (this.selected.type != \"edge\")\n            return;\n        var edge_idx = this.selected.inner;\n        this.embedding.edge_data[edge_idx].end_ang_override = val;\n        this.draw();\n    };\n    EmbeddingEditor.prototype.set_out_angle_selected = function (angle) {\n        if (this.selected.type != \"vertex\")\n            return;\n        var v = this.selected.inner;\n        this.embedding.vert_data[v].spread_out = angle;\n        this.draw();\n    };\n    EmbeddingEditor.prototype.set_in_angle_selected = function (angle) {\n        if (this.selected.type != \"vertex\")\n            return;\n        var v = this.selected.inner;\n        this.embedding.vert_data[v].spread_in = angle;\n        this.draw();\n    };\n    EmbeddingEditor.prototype.update_sidebar = function () {\n        this.add_edge_button.disabled = this.selected.type != \"pair_verts\";\n        this.remove_edge_button.disabled = this.selected.type != \"edge\";\n        if (this.selected.type == \"pair_edges\") {\n            var _a = this.selected.inner, i = _a[0], j = _a[1];\n            this.swap_end_button.disabled =\n                this.edges_shared_end(i, j).is_none();\n            this.swap_start_button.disabled =\n                this.edges_shared_start(i, j).is_none();\n        }\n        else {\n            this.swap_end_button.disabled = true;\n            this.swap_start_button.disabled = true;\n        }\n        if (this.selected.type == \"vertex\") {\n            this.inout.style.display = \"block\";\n            var i = this.selected.inner;\n            var vd = this.embedding.vert_data[i];\n            this.in_spread_spinner.value = Math.round(vd.spread_in * (180 / Math.PI)).toString();\n            this.out_spread_spinner.value = Math.round(vd.spread_out * (180 / Math.PI)).toString();\n            this.vps_row.style.display = \"\";\n            this.vert_pos_spinner.set_value(vd.position);\n        }\n        else {\n            this.inout.style.display = \"none\";\n            this.vps_row.style.display = \"none\";\n        }\n        if (this.selected.type == \"edge\") {\n            this.start_angle_override.set_visible(true);\n            this.end_angle_override.set_visible(true);\n            var i = this.selected.inner;\n            var vd = this.embedding.edge_data[i];\n            this.start_angle_override.set_value(vd.start_ang_override);\n            this.end_angle_override.set_value(vd.end_ang_override);\n        }\n        else {\n            this.start_angle_override.set_visible(false);\n            this.end_angle_override.set_visible(false);\n        }\n    };\n    EmbeddingEditor.prototype.handle_keypress = function (ev) {\n        if (in_typable_box())\n            return;\n        if (ev.key == \"Backspace\") {\n            this.remove_edge_selected();\n        }\n        if (ev.key.toLowerCase() == \"e\") {\n            this.add_edge_selected();\n        }\n        if (ev.key.toLowerCase() == \"d\" && !ev.shiftKey) {\n            this.swap_at_start_selected();\n        }\n        if (ev.key.toLowerCase() == \"d\" && ev.shiftKey) {\n            this.swap_at_end_selected();\n        }\n        if (ev.key.toLowerCase() == \"w\" && ev.shiftKey)\n            this.change_out_angle_selected(Math.PI / 16);\n        if (ev.key.toLowerCase() == \"s\" && ev.shiftKey)\n            this.change_out_angle_selected(-Math.PI / 16);\n        if (ev.key.toLowerCase() == \"w\" && !ev.shiftKey)\n            this.change_in_angle_selected(Math.PI / 16);\n        if (ev.key.toLowerCase() == \"s\" && !ev.shiftKey)\n            this.change_in_angle_selected(-Math.PI / 16);\n        this.update_sidebar();\n    };\n    EmbeddingEditor.prototype.show_err = function (err) {\n        this.error_box.innerText = err.err_message;\n    };\n    EmbeddingEditor.prototype.clear_err = function () {\n        this.error_box.innerText = \"\";\n    };\n    /*\n    Operations\n    */\n    EmbeddingEditor.prototype.add_edge = function (start, end) {\n        if (start == end)\n            return;\n        var try_add_res = this.embedding.add_edge(start, end);\n        if (try_add_res.is_ok()) {\n            if (this.editor_options.reembed_add())\n                this.embedding.default_edges();\n            this.draw();\n            this.clear_err();\n        }\n        else {\n            this.show_err(try_add_res.error());\n        }\n    };\n    EmbeddingEditor.prototype.remove_edge = function (idx) {\n        var try_add_res = this.embedding.remove_edge(idx);\n        if (try_add_res) {\n            if (this.editor_options.reembed_remove())\n                this.embedding.default_edges();\n            this.draw();\n            this.clear_err();\n        }\n    };\n    EmbeddingEditor.prototype.swap_at_start = function (e1, e2) {\n        var start_opt = this.edges_shared_start(e1, e2);\n        if (start_opt.is_none())\n            return;\n        var start = start_opt.unwrap();\n        var dag = this.embedding.dag;\n        var frame = this.embedding.dag.get_out_edges(start).unwrap();\n        for (var i = 0; i < frame.length; i++) {\n            if (frame[i] == e1)\n                frame[i] = e2;\n            else if (frame[i] == e2)\n                frame[i] = e1;\n        }\n        var success = dag.reorder_out_edges(start, frame);\n        if (success) {\n            if (this.editor_options.reembed_swap())\n                this.embedding.default_edges();\n            this.draw();\n            this.clear_err();\n        }\n    };\n    EmbeddingEditor.prototype.swap_at_end = function (e1, e2) {\n        var end_opt = this.edges_shared_end(e1, e2);\n        if (end_opt.is_none())\n            return;\n        var end = end_opt.unwrap();\n        var dag = this.embedding.dag;\n        var frame = this.embedding.dag.get_in_edges(end).unwrap();\n        for (var i = 0; i < frame.length; i++) {\n            if (frame[i] == e1)\n                frame[i] = e2;\n            else if (frame[i] == e2)\n                frame[i] = e1;\n        }\n        var success = dag.reorder_in_edges(end, frame);\n        if (success) {\n            if (this.swap_reembed_cb.checked)\n                this.embedding.default_edges();\n            this.draw();\n            this.clear_err();\n        }\n    };\n    /*\n    Code for drawing\n    */\n    EmbeddingEditor.prototype.draw = function () {\n        var ctx = this.canvas.get_ctx();\n        var data = this.embedding.bake();\n        ctx.clear();\n        for (var _i = 0, _a = data.edges; _i < _a.length; _i++) {\n            var edge = _a[_i];\n            ctx.draw_bez(edge, this.draw_options.edge_color(), this.draw_options.edge_weight(), true);\n        }\n        if (this.draw_options.arrows())\n            ctx.decorate_edges_arrow(data);\n        this.draw_selection_edge(data, ctx);\n        this.draw_drag_edge(data, ctx);\n        for (var _b = 0, _c = data.verts; _b < _c.length; _b++) {\n            var vert = _c[_b];\n            ctx.draw_node(vert);\n        }\n        if (this.draw_options.label_framing())\n            ctx.decorate_edges_num(this.embedding.dag, data);\n        this.draw_selection_vert(data, ctx);\n        this.draw_tangent_handles(data, ctx);\n    };\n    EmbeddingEditor.prototype.draw_selection_vert = function (data, ctx) {\n        var verts = [];\n        if (this.selected.type == \"vertex\") {\n            verts = [this.selected.inner];\n        }\n        else if (this.selected.type == \"pair_verts\") {\n            verts = this.selected.inner;\n        }\n        for (var _i = 0, verts_1 = verts; _i < verts_1.length; _i++) {\n            var vert = verts_1[_i];\n            if (0 > vert || vert >= data.verts.length) {\n                this.change_selection(Selection.none());\n                return;\n            }\n            var vpos = data.verts[vert];\n            ctx.draw_circ(vpos, this.draw_options.selection_color(), this.draw_options.vert_radius() + 4);\n        }\n    };\n    EmbeddingEditor.prototype.draw_selection_edge = function (data, ctx) {\n        var edges = [];\n        if (this.selected.type == \"edge\") {\n            edges = [this.selected.inner];\n        }\n        else if (this.selected.type == \"pair_edges\") {\n            edges = this.selected.inner;\n        }\n        for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {\n            var edge = edges_1[_i];\n            if (0 > edge || edge >= data.edges.length) {\n                this.change_selection(Selection.none());\n                return;\n            }\n            var bez = data.edges[edge];\n            ctx.draw_bez(bez, this.draw_options.selection_color(), this.draw_options.edge_weight() + 5, false);\n        }\n    };\n    EmbeddingEditor.prototype.draw_drag_edge = function (data, ctx) {\n        if (!this.e_drag.dragging)\n            return;\n        var start = data.verts[this.e_drag.vert];\n        var end = this.canvas.local_trans_inv(this.mouse_pos);\n        ctx.draw_line(start, end, this.draw_options.edge_color(), this.draw_options.edge_weight());\n    };\n    EmbeddingEditor.prototype.draw_tangent_handles = function (data, ctx) {\n        if (this.selected.type != \"edge\")\n            return;\n        var edge = this.selected.inner;\n        var edge_data = this.embedding.edge_data[edge];\n        var bez = data.edges[edge];\n        if (edge_data.start_ang_override.type == \"vec-abs\") {\n            ctx.draw_line(bez.start_point, bez.cp1, this.draw_options.handle_color() + \"88\", this.draw_options.tangent_arm_weight());\n            ctx.draw_circ(bez.cp1, this.draw_options.handle_color(), this.draw_options.tangent_handle_size());\n        }\n        if (edge_data.end_ang_override.type == \"vec-abs\") {\n            ctx.draw_line(bez.end_point, bez.cp2, this.draw_options.handle_color() + \"88\", this.draw_options.tangent_arm_weight());\n            ctx.draw_circ(bez.cp2, this.draw_options.handle_color(), this.draw_options.tangent_handle_size());\n        }\n    };\n    /*\n    Utility functions\n    */\n    EmbeddingEditor.prototype.get_vertex_at = function (position) {\n        var dag = this.embedding.bake();\n        for (var i = 0; i < dag.verts.length; i++) {\n            var vert_pos = this.canvas.local_trans(dag.verts[i]);\n            if (position.sub(vert_pos).norm() <= this.draw_options.vert_radius())\n                return result_1.Option.some(i);\n        }\n        return result_1.Option.none();\n    };\n    EmbeddingEditor.prototype.get_edge_at = function (position) {\n        var _this = this;\n        var dag = this.embedding.bake();\n        for (var i = dag.edges.length - 1; i >= 0; i--) {\n            var bez = dag.edges[i].transform(function (v) { return _this.canvas.local_trans(v); });\n            if (bez.distance_to(position) <= this.draw_options.edge_weight())\n                return result_1.Option.some(i);\n        }\n        return result_1.Option.none();\n    };\n    EmbeddingEditor.prototype.edges_shared_start = function (e1, e2) {\n        var edge1 = this.embedding.dag.get_edge(e1);\n        var edge2 = this.embedding.dag.get_edge(e2);\n        if (edge1.is_none() || edge2.is_none())\n            return result_1.Option.none();\n        var start1 = edge1.unwrap().start;\n        var start2 = edge2.unwrap().start;\n        if (start1 == start2)\n            return result_1.Option.some(start1);\n        else\n            return result_1.Option.none();\n    };\n    EmbeddingEditor.prototype.edges_shared_end = function (e1, e2) {\n        var edge1 = this.embedding.dag.get_edge(e1);\n        var edge2 = this.embedding.dag.get_edge(e2);\n        if (edge1.is_none() || edge2.is_none())\n            return result_1.Option.none();\n        var end1 = edge1.unwrap().end;\n        var end2 = edge2.unwrap().end;\n        if (end1 == end2)\n            return result_1.Option.some(end1);\n        else\n            return result_1.Option.none();\n    };\n    EmbeddingEditor.prototype.get_handle_at = function (position) {\n        if (this.selected.type != \"edge\")\n            return result_1.Option.none();\n        var idx = this.selected.inner;\n        var ed = this.embedding.edge_data[idx];\n        if (ed.end_ang_override.type != \"vec-abs\" && ed.start_ang_override.type != \"vec-abs\")\n            return result_1.Option.none();\n        var dag = this.embedding.bake();\n        if (ed.start_ang_override.type == \"vec-abs\") {\n            var point = this.canvas.local_trans(dag.edges[idx].cp1);\n            if (position.sub(point).norm() <= this.draw_options.tangent_handle_size())\n                return result_1.Option.some({ edge: idx, side: \"start\" });\n        }\n        if (ed.end_ang_override.type == \"vec-abs\") {\n            var point = this.canvas.local_trans(dag.edges[idx].cp2);\n            if (position.sub(point).norm() <= this.draw_options.tangent_handle_size())\n                return result_1.Option.some({ edge: idx, side: \"end\" });\n        }\n        return result_1.Option.none();\n    };\n    return EmbeddingEditor;\n}());\nexports.EmbeddingEditor = EmbeddingEditor;\nvar TYPABLE = [\n    \"number\", \"email\", \"password\", \"text\"\n];\nfunction in_typable_box() {\n    var active = document.activeElement;\n    if (!active)\n        return false;\n    if (active.nodeName != \"INPUT\")\n        return false;\n    var a_input = active;\n    return TYPABLE.includes(a_input.type.toLowerCase());\n}\n\n\n//# sourceURL=webpack://dkk/./js_src/modes/embedding_editor.js?");

/***/ }),

/***/ "./js_src/popup/cv-open.js":
/*!*********************************!*\
  !*** ./js_src/popup/cv-open.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CVOpenPopup = void 0;\nvar dag_layout_1 = __webpack_require__(/*! ../draw/dag_layout */ \"./js_src/draw/dag_layout.js\");\nvar preset_1 = __webpack_require__(/*! ../preset */ \"./js_src/preset.js\");\nvar popup_1 = __webpack_require__(/*! ./popup */ \"./js_src/popup/popup.js\");\nvar CVOpenPopup = /** @class */ (function (_super) {\n    __extends(CVOpenPopup, _super);\n    function CVOpenPopup(base, parent) {\n        var _this = _super.call(this, base, \"Open\", function () { return parent.popup_open = false; }) || this;\n        _this.parent = parent;\n        _this.error_div = document.createElement(\"div\");\n        _this.error_div.id = \"open-error-zone\";\n        _this.popup_body.appendChild(_this.error_div);\n        var table = document.createElement(\"table\");\n        _this.popup_body.appendChild(table);\n        _this.table = table;\n        var preset_dropdown = document.createElement(\"select\");\n        for (var _i = 0, PRESETS_1 = preset_1.PRESETS; _i < PRESETS_1.length; _i++) {\n            var preset = PRESETS_1[_i];\n            var opt = document.createElement(\"option\");\n            opt.value = preset.name;\n            opt.innerText = preset.name;\n            preset_dropdown.appendChild(opt);\n        }\n        _this.preset_dropdown = preset_dropdown;\n        var preset_button = document.createElement(\"button\");\n        preset_button.innerText = \"Open\";\n        preset_button.onclick = function () { return _this.load_preset(); };\n        _this.add_row(\"From preset\", preset_dropdown, preset_button);\n        var file_open = document.createElement(\"input\");\n        file_open.type = \"file\";\n        file_open.accept = \"json\";\n        file_open.addEventListener(\"change\", function () { return __awaiter(_this, void 0, void 0, function () {\n            var file, reader_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                if (file_open.files)\n                    if (file_open.files.length == 1) {\n                        file = file_open.files[0];\n                        reader_1 = new FileReader();\n                        reader_1.onload = function () {\n                            var fe = dag_layout_1.FramedDAGEmbedding.from_json(reader_1.result);\n                            if (fe.is_err()) {\n                                _this.show_err(fe.error().err_message);\n                                return;\n                            }\n                            _this.parent.set_dag(fe.unwrap());\n                            _this.close();\n                        };\n                        reader_1.onerror = function () {\n                            var _a;\n                            _this.show_err((_a = reader_1.error) === null || _a === void 0 ? void 0 : _a.message);\n                        };\n                        reader_1.readAsText(file);\n                    }\n                return [2 /*return*/];\n            });\n        }); });\n        _this.add_row(\"From file\", file_open, null);\n        return _this;\n    }\n    CVOpenPopup.prototype.load_preset = function () {\n        var name = this.preset_dropdown.value;\n        this.parent.set_dag((0, preset_1.preset_dag_embedding)(name));\n        this.close();\n    };\n    CVOpenPopup.prototype.add_row = function (text, element1, element2) {\n        var row = document.createElement(\"tr\");\n        var id = \"option-\" + text;\n        var name = document.createElement(\"td\");\n        var name_label = document.createElement(\"label\");\n        name_label.htmlFor = id;\n        name_label.innerText = text;\n        name.appendChild(name_label);\n        row.appendChild(name);\n        var control1 = document.createElement(\"td\");\n        if (element1) {\n            element1.id = id;\n            control1.appendChild(element1);\n        }\n        row.appendChild(control1);\n        var control2 = document.createElement(\"td\");\n        if (element2) {\n            control2.appendChild(element2);\n        }\n        row.appendChild(control2);\n        this.table.appendChild(row);\n    };\n    CVOpenPopup.prototype.show_err = function (err) {\n        this.error_div.innerText = err;\n    };\n    return CVOpenPopup;\n}(popup_1.Popup));\nexports.CVOpenPopup = CVOpenPopup;\n\n\n//# sourceURL=webpack://dkk/./js_src/popup/cv-open.js?");

/***/ }),

/***/ "./js_src/popup/ee-open.js":
/*!*********************************!*\
  !*** ./js_src/popup/ee-open.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EEOpenPopup = void 0;\nvar cv_open_1 = __webpack_require__(/*! ./cv-open */ \"./js_src/popup/cv-open.js\");\nvar EEOpenPopup = /** @class */ (function (_super) {\n    __extends(EEOpenPopup, _super);\n    function EEOpenPopup(base, parent) {\n        return _super.call(this, base, parent) || this;\n    }\n    return EEOpenPopup;\n}(cv_open_1.CVOpenPopup));\nexports.EEOpenPopup = EEOpenPopup;\n\n\n//# sourceURL=webpack://dkk/./js_src/popup/ee-open.js?");

/***/ }),

/***/ "./js_src/popup/new.js":
/*!*****************************!*\
  !*** ./js_src/popup/new.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NewPopup = void 0;\nvar popup_1 = __webpack_require__(/*! ./popup */ \"./js_src/popup/popup.js\");\nvar NewPopup = /** @class */ (function (_super) {\n    __extends(NewPopup, _super);\n    function NewPopup(base, parent) {\n        var _this = _super.call(this, base, \"New\", function () { return parent.popup_open = false; }) || this;\n        _this.parent = parent;\n        var table = document.createElement(\"table\");\n        var row = document.createElement(\"tr\");\n        var col1 = document.createElement(\"td\");\n        var col2 = document.createElement(\"td\");\n        var col3 = document.createElement(\"td\");\n        _this.popup_body.appendChild(table);\n        table.appendChild(row);\n        row.appendChild(col1);\n        row.appendChild(col2);\n        row.appendChild(col3);\n        var label = document.createElement(\"label\");\n        label.htmlFor = \"new-num\";\n        label.innerText = \"Number of vertices\";\n        col1.appendChild(label);\n        _this.input = document.createElement(\"input\");\n        _this.input.type = \"number\";\n        _this.input.value = \"4\";\n        _this.input.min = \"1\";\n        _this.input.id = \"new-num\";\n        col2.appendChild(_this.input);\n        var button = document.createElement(\"button\");\n        button.innerText = \"Create\";\n        button.onclick = function (ev) {\n            _this.done();\n        };\n        col3.appendChild(button);\n        return _this;\n    }\n    NewPopup.prototype.done = function () {\n        var num = parseInt(this.input.value);\n        this.close();\n        this.parent.set_new_clique(num);\n    };\n    return NewPopup;\n}(popup_1.Popup));\nexports.NewPopup = NewPopup;\n\n\n//# sourceURL=webpack://dkk/./js_src/popup/new.js?");

/***/ }),

/***/ "./js_src/popup/popup.js":
/*!*******************************!*\
  !*** ./js_src/popup/popup.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Popup = void 0;\nvar Popup = /** @class */ (function () {\n    function Popup(body, title_name, close_callback) {\n        var _this = this;\n        this.close_callback = close_callback;\n        var base = document.createElement(\"div\");\n        base.id = \"shadow\";\n        base.className = \"fullscreen\";\n        this.base = base;\n        body.appendChild(base);\n        var window = document.createElement(\"div\");\n        window.className = \"popup-window\";\n        base.appendChild(window);\n        this.window = window;\n        var top_bar = document.createElement(\"div\");\n        top_bar.className = \"popup-top-bar\";\n        window.appendChild(top_bar);\n        this.top_bar = top_bar;\n        var title = document.createElement(\"h3\");\n        title.innerText = title_name;\n        top_bar.appendChild(title);\n        var xout = document.createElement(\"div\");\n        xout.className = \"popup-xout\";\n        xout.innerText = \"X\";\n        xout.onclick = function () {\n            _this.close();\n        };\n        top_bar.appendChild(xout);\n        this.xout = xout;\n        var popup_body = document.createElement(\"div\");\n        popup_body.className = \"popup-body\";\n        this.window.appendChild(popup_body);\n        this.popup_body = popup_body;\n    }\n    Popup.prototype.close = function () {\n        this.base.remove();\n        this.close_callback();\n    };\n    return Popup;\n}());\nexports.Popup = Popup;\n\n\n//# sourceURL=webpack://dkk/./js_src/popup/popup.js?");

/***/ }),

/***/ "./js_src/popup/settings.js":
/*!**********************************!*\
  !*** ./js_src/popup/settings.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SettingsPopup = void 0;\nvar popup_1 = __webpack_require__(/*! ./popup */ \"./js_src/popup/popup.js\");\nvar SettingsPopup = /** @class */ (function (_super) {\n    __extends(SettingsPopup, _super);\n    function SettingsPopup(base, parent) {\n        var _this = _super.call(this, base, \"Settings\", function () { return parent.popup_open = false; }) || this;\n        _this.parent = parent;\n        var base_table = document.createElement(\"table\");\n        base_table.className = \"settings-column-table\";\n        var column_holder = document.createElement(\"tr\");\n        _this.popup_body.appendChild(base_table);\n        base_table.appendChild(column_holder);\n        var col1 = document.createElement(\"td\");\n        var col2 = document.createElement(\"td\");\n        column_holder.appendChild(col1);\n        column_holder.appendChild(col2);\n        //FIRST COLUMN\n        var col1_table = document.createElement(\"table\");\n        col1_table.className = \"settings-table\";\n        col1.appendChild(col1_table);\n        SettingsPopup.add_title(col1_table, \"DAG\");\n        _this.vert_radius_spinner = SettingsPopup.add_stepper_row(col1_table, \"Vertex radius\", \"settings-vert-radius\", function (val) { return _this.parent.draw_options.set_vert_radius(val); });\n        _this.edge_weight_spinner = SettingsPopup.add_stepper_row(col1_table, \"Edge weight\", \"settings-edge-weight\", function (val) { return _this.parent.draw_options.set_edge_weight(val); });\n        _this.route_weight_spinner = SettingsPopup.add_stepper_row(col1_table, \"Route weight\", \"settings-route-weight\", function (val) { return _this.parent.draw_options.set_route_weight(val); });\n        _this.label_checkbox = SettingsPopup.add_tickbox_row(col1_table, \"Framing labels\", \"settings-labels-cb\", function (val) { return _this.parent.draw_options.set_label_framing(val); });\n        _this.arrow_checkbox = SettingsPopup.add_tickbox_row(col1_table, \"Direction arrows\", \"settings-arrows-cb\", function (val) { return _this.parent.draw_options.set_arrows(val); });\n        SettingsPopup.add_title(col1_table, \"Hasse diagram\");\n        _this.hasse_weight_spinner = SettingsPopup.add_stepper_row(col1_table, \"Hasse edge weight\", \"settings-hasse-weight\", function (val) { return _this.parent.draw_options.set_hasse_edge_weight(val); });\n        _this.hasse_show_clique_cb = SettingsPopup.add_tickbox_row(col1_table, \"Show cliques as nodes\", \"settings-hasse-cliques\", function (b) { return _this.parent.draw_options.set_hasse_show_cliques(b); });\n        _this.hasse_clique_spinner = SettingsPopup.add_stepper_row(col1_table, \"Clique size\", \"settings-h-clique-size\", function (val) { return _this.parent.draw_options.set_hasse_mini_dag_size(val); });\n        _this.hasse_vert_spinner = SettingsPopup.add_stepper_row(col1_table, \"Vertex size\", \"settings-h-vertex-size\", function (val) { return _this.parent.draw_options.set_hasse_mini_vert_rad(val); });\n        _this.hasse_route_spinner = SettingsPopup.add_stepper_row(col1_table, \"Route weight\", \"settings-h-route-weight\", function (val) { return _this.parent.draw_options.set_hasse_mini_route_weight(val); });\n        SettingsPopup.add_title(col1_table, \"Polytope\");\n        _this.simplrend_dropdown = SettingsPopup.add_selector_row(col1_table, \"Simplex mode\", \"settings-simpl-mode\", [\n            [\"solid\", \"solid\"],\n            [\"dots\", \"dots\"],\n            [\"blank\", \"blank\"]\n        ], function (val) {\n            _this.parent.draw_options.set_simplex_render_mode(val);\n        });\n        _this.dot_on_top_cb = SettingsPopup.add_tickbox_row(col1_table, \"Draw dots on top\", \"settings-dots-on-top\", function (b) { return _this.parent.draw_options.set_dot_on_top(b); });\n        _this.dot_shade_cb = SettingsPopup.add_tickbox_row(col1_table, \"Shade dots\", \"settings-dots-shade\", function (b) { return _this.parent.draw_options.set_dot_shade(b); });\n        _this.dot_radius_spinner = SettingsPopup.add_stepper_row(col1_table, \"Dot radius\", \"settings-dot-radius\", function (v) { return _this.parent.draw_options.set_dot_radius(v); });\n        //SECOND COLUMN\n        var col2_table = document.createElement(\"table\");\n        col2_table.className = \"settings-table\";\n        col2.appendChild(col2_table);\n        SettingsPopup.add_title(col2_table, \"Colors\");\n        _this.vertex_color_selector = SettingsPopup.add_color_row(col2_table, \"Vertex color\", \"settings-vert-color\", function (val) {\n            _this.parent.draw_options.set_vertex_color(val);\n        });\n        _this.background_color_selector = SettingsPopup.add_color_row(col2_table, \"Background color\", \"settings-bg-color\", function (val) {\n            _this.parent.draw_options.set_background_color(val);\n        });\n        _this.polytope_color_selector = SettingsPopup.add_color_row(col2_table, \"Polytope color\", \"settings-polytope-color\", function (val) {\n            _this.parent.draw_options.set_polytope_color(val);\n        });\n        _this.simplex_color_selector = SettingsPopup.add_color_row(col2_table, \"Simplex color\", \"settings-simplex-color\", function (val) {\n            _this.parent.draw_options.set_simplex_color(val);\n        });\n        //RESET BUTTON\n        _this.reset_button = document.createElement(\"button\");\n        _this.reset_button.onclick = function (ev) { return _this.reset_settings(); };\n        _this.reset_button.innerText = \"Reset\";\n        _this.reset_button.id = \"reset-button\";\n        _this.popup_body.appendChild(_this.reset_button);\n        _this.sync_with_settings();\n        return _this;\n    }\n    SettingsPopup.prototype.reset_settings = function () {\n        this.parent.draw_options.reset();\n        this.sync_with_settings();\n    };\n    SettingsPopup.prototype.sync_with_settings = function () {\n        this.simplrend_dropdown.value =\n            this.parent.draw_options.simplex_render_mode();\n        this.vert_radius_spinner.value =\n            this.parent.draw_options.vert_radius().toString();\n        this.edge_weight_spinner.value =\n            this.parent.draw_options.edge_weight().toString();\n        this.route_weight_spinner.value =\n            this.parent.draw_options.route_weight().toString();\n        this.label_checkbox.checked =\n            this.parent.draw_options.label_framing();\n        this.arrow_checkbox.checked =\n            this.parent.draw_options.arrows();\n        this.hasse_weight_spinner.value =\n            this.parent.draw_options.hasse_edge_weight().toString();\n        this.hasse_show_clique_cb.checked =\n            this.parent.draw_options.hasse_show_cliques();\n        this.hasse_clique_spinner.value =\n            this.parent.draw_options.hasse_mini_dag_size().toString();\n        this.hasse_vert_spinner.value =\n            this.parent.draw_options.hasse_mini_vert_rad().toString();\n        this.hasse_route_spinner.value =\n            this.parent.draw_options.hasse_mini_route_weight().toString();\n        this.vertex_color_selector.value =\n            this.parent.draw_options.vertex_color();\n        this.background_color_selector.value =\n            this.parent.draw_options.background_color();\n        this.polytope_color_selector.value =\n            this.parent.draw_options.polytope_color();\n        this.simplex_color_selector.value =\n            this.parent.draw_options.simplex_color();\n        this.dot_on_top_cb.checked =\n            this.parent.draw_options.dot_on_top();\n        this.dot_shade_cb.checked =\n            this.parent.draw_options.dot_shade();\n        this.dot_radius_spinner.value =\n            this.parent.draw_options.dot_radius().toString();\n    };\n    SettingsPopup.add_stepper_row = function (table, name, id, onchange) {\n        var label = document.createElement(\"label\");\n        label.htmlFor = id;\n        label.innerText = name;\n        var spinner = document.createElement(\"input\");\n        spinner.type = \"number\";\n        spinner.id = id;\n        spinner.step = \"1\";\n        spinner.min = \"1\";\n        spinner.addEventListener(\"change\", function (ev) {\n            onchange(parseInt(spinner.value));\n        });\n        var row = document.createElement(\"tr\");\n        var d1 = document.createElement(\"td\");\n        var d2 = document.createElement(\"td\");\n        row.appendChild(d1);\n        row.appendChild(d2);\n        d1.appendChild(label);\n        d2.appendChild(spinner);\n        table.appendChild(row);\n        return spinner;\n    };\n    SettingsPopup.add_selector_row = function (table, name, id, name_val_pairs, onchange) {\n        var label = document.createElement(\"label\");\n        label.htmlFor = id;\n        label.innerText = name;\n        var selector = document.createElement(\"select\");\n        selector.id = id;\n        for (var _i = 0, name_val_pairs_1 = name_val_pairs; _i < name_val_pairs_1.length; _i++) {\n            var pair = name_val_pairs_1[_i];\n            var opt = document.createElement(\"option\");\n            opt.value = pair[1];\n            opt.innerText = pair[0];\n            selector.appendChild(opt);\n        }\n        selector.addEventListener(\"change\", function (ev) {\n            onchange(selector.value);\n        });\n        var row = document.createElement(\"tr\");\n        var d1 = document.createElement(\"td\");\n        var d2 = document.createElement(\"td\");\n        row.appendChild(d1);\n        row.appendChild(d2);\n        d1.appendChild(label);\n        d2.appendChild(selector);\n        table.appendChild(row);\n        return selector;\n    };\n    SettingsPopup.add_title = function (table, name) {\n        var row = document.createElement(\"tr\");\n        var d1 = document.createElement(\"td\");\n        var d2 = document.createElement(\"td\");\n        row.appendChild(d1);\n        row.appendChild(d2);\n        table.appendChild(row);\n        var title = document.createElement(\"div\");\n        title.className = \"settings-head\";\n        title.innerText = name;\n        d1.appendChild(title);\n    };\n    SettingsPopup.add_color_row = function (table, name, id, onchange) {\n        var label = document.createElement(\"label\");\n        label.htmlFor = id;\n        label.innerText = name;\n        var colorsel = document.createElement(\"input\");\n        colorsel.type = \"color\";\n        colorsel.id = id;\n        colorsel.addEventListener(\"change\", function (ev) {\n            onchange(colorsel.value);\n        });\n        var row = document.createElement(\"tr\");\n        var d1 = document.createElement(\"td\");\n        var d2 = document.createElement(\"td\");\n        row.appendChild(d1);\n        row.appendChild(d2);\n        d1.appendChild(label);\n        d2.appendChild(colorsel);\n        table.appendChild(row);\n        return colorsel;\n    };\n    SettingsPopup.add_tickbox_row = function (table, name, id, onchange) {\n        var label = document.createElement(\"label\");\n        label.htmlFor = id;\n        label.innerText = name;\n        var tickbox = document.createElement(\"input\");\n        tickbox.type = \"checkbox\";\n        tickbox.id = id;\n        tickbox.addEventListener(\"change\", function (ev) {\n            onchange(tickbox.checked);\n        });\n        var row = document.createElement(\"tr\");\n        var d1 = document.createElement(\"td\");\n        var d2 = document.createElement(\"td\");\n        row.appendChild(d1);\n        row.appendChild(d2);\n        d1.appendChild(label);\n        d2.appendChild(tickbox);\n        table.appendChild(row);\n        return tickbox;\n    };\n    return SettingsPopup;\n}(popup_1.Popup));\nexports.SettingsPopup = SettingsPopup;\n\n\n//# sourceURL=webpack://dkk/./js_src/popup/settings.js?");

/***/ }),

/***/ "./js_src/popup/shortcuts.js":
/*!***********************************!*\
  !*** ./js_src/popup/shortcuts.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShortcutsPopup = void 0;\nvar popup_1 = __webpack_require__(/*! ./popup */ \"./js_src/popup/popup.js\");\nvar ShortcutsPopup = /** @class */ (function (_super) {\n    __extends(ShortcutsPopup, _super);\n    function ShortcutsPopup(base, data) {\n        var _this = _super.call(this, base, \"Shortcuts\", function () { }) || this;\n        var table = document.createElement(\"table\");\n        table.id = \"shortcuts-table\";\n        _this.popup_body.appendChild(table);\n        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n            var row_data = data_1[_i];\n            var row = document.createElement(\"tr\");\n            table.appendChild(row);\n            var col1 = document.createElement(\"td\");\n            col1.innerText = row_data[0];\n            var col2 = document.createElement(\"td\");\n            col2.innerText = row_data[1];\n            row.appendChild(col1);\n            row.appendChild(col2);\n        }\n        return _this;\n    }\n    return ShortcutsPopup;\n}(popup_1.Popup));\nexports.ShortcutsPopup = ShortcutsPopup;\n\n\n//# sourceURL=webpack://dkk/./js_src/popup/shortcuts.js?");

/***/ }),

/***/ "./js_src/preset.js":
/*!**************************!*\
  !*** ./js_src/preset.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PRESETS = void 0;\nexports.preset_dag_embedding = preset_dag_embedding;\nexports.caracol = caracol;\nexports.caracol_emb = caracol_emb;\nvar dag_layout_1 = __webpack_require__(/*! ./draw/dag_layout */ \"./js_src/draw/dag_layout.js\");\nvar dag_1 = __webpack_require__(/*! ./math/dag */ \"./js_src/math/dag.js\");\nvar num_1 = __webpack_require__(/*! ./util/num */ \"./js_src/util/num.js\");\nexports.PRESETS = [\n    { name: \"cube\" },\n    { name: \"cube-twist\" },\n    { name: \"square\" },\n    { name: \"caracol-4\" },\n    { name: \"caracol-5\" },\n    { name: \"test-c-4\" },\n    { name: \"psuedopants\" }\n];\nfunction preset_dag(name) {\n    if (name == \"cube\") {\n        var out = new dag_1.FramedDAG(4);\n        out.add_edge(0, 1).unwrap();\n        out.add_edge(0, 1).unwrap();\n        out.add_edge(1, 2).unwrap();\n        out.add_edge(1, 2).unwrap();\n        out.add_edge(2, 3).unwrap();\n        out.add_edge(2, 3).unwrap();\n        return out;\n    }\n    else if (name == \"cube-twist\") {\n        var out = preset_dag(\"cube\");\n        if (!out.reorder_in_edges(2, [3, 2]))\n            throw Error(\"Something went wrong with test dag 2!\");\n        return out;\n    }\n    else if (name == \"test-c-4\") {\n        var out = new dag_1.FramedDAG(4);\n        out.add_edge(0, 2);\n        out.add_edge(0, 1);\n        out.add_edge(0, 1);\n        out.add_edge(1, 2);\n        out.add_edge(2, 3);\n        out.add_edge(1, 3);\n        return out;\n    }\n    else if (name == \"psuedopants\") {\n        var out = new dag_1.FramedDAG(5);\n        out.add_edge(0, 1);\n        out.add_edge(0, 2);\n        out.add_edge(1, 3);\n        out.add_edge(1, 3);\n        out.add_edge(2, 3);\n        out.add_edge(2, 3);\n        out.add_edge(3, 4);\n        out.add_edge(3, 4);\n        return out;\n    }\n    else if (name == \"square\") {\n        var out = new dag_1.FramedDAG(3);\n        out.add_edge(0, 1).unwrap();\n        out.add_edge(0, 1).unwrap();\n        out.add_edge(1, 2).unwrap();\n        out.add_edge(1, 2).unwrap();\n        return out;\n    }\n    console.warn(\"Invalid preset_dag name: \".concat(name, \", returning cube.\"));\n    return preset_dag(\"cube\");\n}\nfunction preset_dag_embedding(name) {\n    var dag = preset_dag(name);\n    var emb = new dag_layout_1.FramedDAGEmbedding(dag);\n    if (name == \"caracol-4\") {\n        emb = caracol_emb(4);\n    }\n    else if (name == \"caracol-5\") {\n        emb = caracol_emb(5);\n    }\n    return emb;\n}\nfunction caracol(num_verts) {\n    var dag = new dag_1.FramedDAG(num_verts);\n    for (var i = num_verts - 2; i > 0; i--)\n        dag.add_edge(0, i);\n    for (var i = 0; i < num_verts - 1; i++)\n        dag.add_edge(i, i + 1);\n    for (var i = num_verts - 2; i > 0; i--)\n        dag.add_edge(i, num_verts - 1);\n    return dag;\n}\nfunction caracol_emb(num_verts) {\n    var dag = caracol(num_verts);\n    var emb = new dag_layout_1.FramedDAGEmbedding(dag);\n    var excess = (0, num_1.clamp)(num_verts - 4, 0, 4);\n    var ang_max = Math.PI / 4 + excess * Math.PI / 16;\n    for (var i = 0; i < num_verts - 2; i++) {\n        var ang = -ang_max * (1 - i / (num_verts - 2));\n        emb.edge_data[i].start_ang_override = dag_layout_1.AngleOverride.relative(ang);\n    }\n    //spine: [num_verts-2..2*num_verts-3]\n    for (var i = num_verts - 2; i < 2 * num_verts - 3; i++) {\n        emb.edge_data[i].start_ang_override = dag_layout_1.AngleOverride.relative(0);\n        emb.edge_data[i].end_ang_override = dag_layout_1.AngleOverride.relative(0);\n    }\n    for (var i = 0; i < num_verts - 2; i++) {\n        var j = i + 2 * num_verts - 3;\n        var ang = -ang_max * ((i + 1) / (num_verts - 2));\n        emb.edge_data[j].end_ang_override = dag_layout_1.AngleOverride.relative(ang);\n    }\n    return emb;\n}\n\n\n//# sourceURL=webpack://dkk/./js_src/preset.js?");

/***/ }),

/***/ "./js_src/subelements/action_box.js":
/*!******************************************!*\
  !*** ./js_src/subelements/action_box.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActionBox = void 0;\nvar shortcuts_1 = __webpack_require__(/*! ../popup/shortcuts */ \"./js_src/popup/shortcuts.js\");\nvar ActionBox = /** @class */ (function () {\n    function ActionBox(box) {\n        this.box = box;\n        this.table = document.createElement(\"table\");\n        this.box.appendChild(this.table);\n    }\n    ActionBox.create = function () {\n        var element = document.createElement(\"div\");\n        element.className = \"sb-subsection\";\n        var box = new ActionBox(element);\n        return {\n            box: box,\n            element: element\n        };\n    };\n    ActionBox.prototype.add_title = function (title) {\n        var row = document.createElement(\"tr\");\n        var title_elem = document.createElement(\"div\");\n        title_elem.className = \"actionbox-title\";\n        title_elem.innerText = title;\n        row.appendChild(title_elem);\n        this.table.appendChild(row);\n    };\n    ActionBox.prototype.add_tip = function (tip) {\n        var row = document.createElement(\"tr\");\n        var tip_elem = document.createElement(\"div\");\n        tip_elem.className = \"actionbox-tip\";\n        tip_elem.innerText = tip;\n        row.appendChild(tip_elem);\n        this.table.appendChild(row);\n    };\n    ActionBox.prototype.add_button = function (name, action) {\n        var row = document.createElement(\"tr\");\n        var button = document.createElement(\"button\");\n        button.innerText = name;\n        button.onclick = function (ev) { return action(); };\n        row.appendChild(button);\n        this.table.appendChild(row);\n        return button;\n    };\n    ActionBox.prototype.add_dual_spinner = function (name1, id1, minmax1, step1, action1, name2, id2, minmax2, step2, action2) {\n        var row = document.createElement(\"tr\");\n        var table = document.createElement(\"table\");\n        row.appendChild(table);\n        this.table.appendChild(row);\n        var label1 = document.createElement(\"label\");\n        label1.htmlFor = id1;\n        label1.innerText = name1;\n        var label2 = document.createElement(\"label\");\n        label2.htmlFor = id2;\n        label2.innerText = name2;\n        var spinner1 = document.createElement(\"input\");\n        spinner1.type = \"number\";\n        spinner1.addEventListener(\"change\", function (ev) {\n            action1(parseInt(spinner1.value));\n        });\n        spinner1.min = minmax1[0].toString();\n        spinner1.max = minmax1[1].toString();\n        spinner1.step = step1.toString();\n        var spinner2 = document.createElement(\"input\");\n        spinner2.type = \"number\";\n        spinner2.addEventListener(\"change\", function (ev) {\n            action2(parseInt(spinner2.value));\n        });\n        spinner2.min = minmax2[0].toString();\n        spinner2.max = minmax2[1].toString();\n        spinner2.step = step2.toString();\n        var subrow1 = document.createElement(\"tr\");\n        var subcol11 = document.createElement(\"td\");\n        var subcol12 = document.createElement(\"td\");\n        subrow1.appendChild(subcol11);\n        subrow1.appendChild(subcol12);\n        var subrow2 = document.createElement(\"tr\");\n        var subcol21 = document.createElement(\"td\");\n        var subcol22 = document.createElement(\"td\");\n        subrow2.appendChild(subcol21);\n        subrow2.appendChild(subcol22);\n        table.appendChild(subrow1);\n        table.appendChild(subrow2);\n        subcol11.appendChild(label1);\n        subcol12.appendChild(spinner1);\n        subcol21.appendChild(label2);\n        subcol22.appendChild(spinner2);\n        return { row: row, spinner1: spinner1, spinner2: spinner2 };\n    };\n    ActionBox.prototype.add_checkbox = function (name, event) {\n        var checkbox = document.createElement(\"input\");\n        checkbox.type = \"checkbox\";\n        checkbox.onchange = function (ev) { return event(checkbox.checked); };\n        var label = document.createElement(\"label\");\n        label.innerText = name;\n        var div = document.createElement(\"div\");\n        div.appendChild(checkbox);\n        div.appendChild(label);\n        this.add_row(div);\n        return checkbox;\n    };\n    ActionBox.prototype.add_shortcut_popup = function (data) {\n        var main_body = document.getElementsByTagName(\"body\")[0];\n        var row = document.createElement(\"tr\");\n        var place = document.createElement(\"td\");\n        row.appendChild(place);\n        var link = document.createElement(\"a\");\n        link.innerText = \"Shortcuts\";\n        link.className = \"small-link\";\n        link.onclick = function (ev) { return new shortcuts_1.ShortcutsPopup(main_body, data); };\n        place.appendChild(link);\n        this.table.appendChild(row);\n    };\n    ActionBox.prototype.add_row = function (elem) {\n        var row = document.createElement(\"tr\");\n        row.appendChild(elem);\n        this.table.appendChild(row);\n        return row;\n    };\n    ActionBox.prototype.add_labelled_row = function (elem, name) {\n        var label = document.createElement(\"label\");\n        label.innerText = name;\n        var row = document.createElement(\"tr\");\n        var l_row = document.createElement(\"tr\");\n        row.appendChild(l_row);\n        var col1 = document.createElement(\"td\");\n        var col2 = document.createElement(\"td\");\n        l_row.appendChild(col1);\n        l_row.appendChild(col2);\n        col1.appendChild(label);\n        col2.appendChild(elem);\n        this.table.appendChild(row);\n        return row;\n    };\n    ActionBox.prototype.add_space = function (height) {\n        var spacer = document.createElement(\"div\");\n        spacer.style.height = height.toString() + \"px\";\n        this.add_row(spacer);\n    };\n    return ActionBox;\n}());\nexports.ActionBox = ActionBox;\n\n\n//# sourceURL=webpack://dkk/./js_src/subelements/action_box.js?");

/***/ }),

/***/ "./js_src/subelements/angle_override.js":
/*!**********************************************!*\
  !*** ./js_src/subelements/angle_override.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AngleOverrideController = void 0;\nvar dag_layout_1 = __webpack_require__(/*! ../draw/dag_layout */ \"./js_src/draw/dag_layout.js\");\nvar num_1 = __webpack_require__(/*! ../util/num */ \"./js_src/util/num.js\");\nvar vec_spinner_1 = __webpack_require__(/*! ./vec_spinner */ \"./js_src/subelements/vec_spinner.js\");\nvar TYPES = [\"none\", \"relative\", \"absolute\", \"vec-abs\"];\nvar AngleOverrideController = /** @class */ (function () {\n    function AngleOverrideController(name) {\n        var _this = this;\n        this.change_listeners = [];\n        this.base = document.createElement(\"table\");\n        this.base.className = \"angle-override-table\";\n        var row = document.createElement(\"tr\");\n        this.base.appendChild(row);\n        var _a = [\n            document.createElement(\"td\"),\n            document.createElement(\"td\"),\n            document.createElement(\"td\"),\n        ], col1 = _a[0], col2 = _a[1], col3 = _a[2];\n        row.appendChild(col1);\n        row.appendChild(col2);\n        row.appendChild(col3);\n        this.dropdown = document.createElement(\"select\");\n        this.spinner = document.createElement(\"input\");\n        this.vec_spinner = new vec_spinner_1.VecSpinner();\n        this.spinner.type = \"number\";\n        this.spinner.step = \"5\";\n        col1.innerText = name;\n        col2.appendChild(this.dropdown);\n        col3.appendChild(this.spinner);\n        col3.appendChild(this.vec_spinner.base);\n        for (var _i = 0, TYPES_1 = TYPES; _i < TYPES_1.length; _i++) {\n            var val = TYPES_1[_i];\n            var opt = document.createElement(\"option\");\n            opt.value = val;\n            opt.innerText = val;\n            if (val == \"none\")\n                opt.innerText = \"auto\";\n            this.dropdown.appendChild(opt);\n        }\n        this.dropdown.value = \"none\";\n        this.dropdown.addEventListener(\"change\", function (ev) {\n            _this.update();\n            _this.fire_change_listeners();\n        });\n        this.spinner.addEventListener(\"change\", function (ev) { return _this.fire_change_listeners(); });\n        this.vec_spinner.add_change_listeners(function (v) { return _this.fire_change_listeners(); });\n        this.update();\n    }\n    AngleOverrideController.prototype.update = function () {\n        if (this.dropdown.value != \"relative\" && this.dropdown.value != \"absolute\") {\n            this.spinner.style.display = \"none\";\n        }\n        else {\n            this.spinner.style.display = \"block\";\n        }\n        this.vec_spinner.set_visible(this.dropdown.value == \"vec-abs\");\n    };\n    AngleOverrideController.prototype.set_value = function (ov) {\n        if (ov.type == \"absolute\" || ov.type == \"relative\")\n            this.spinner.value = Math.round(ov.inner * (-180 / Math.PI)).toString();\n        else\n            this.spinner.value = \"0\";\n        if (ov.type == \"vec-abs\") {\n            this.vec_spinner.set_value(ov.inner);\n        }\n        else {\n            this.vec_spinner.set_value(num_1.Vector2.right().scale(0.3));\n        }\n        this.dropdown.value = ov.type;\n        this.update();\n    };\n    AngleOverrideController.prototype.get_value = function () {\n        var angle = 0;\n        try {\n            angle = parseInt(this.spinner.value) * (-Math.PI / 180);\n        }\n        catch (_a) { }\n        if (this.dropdown.value == \"none\")\n            return dag_layout_1.AngleOverride.none();\n        if (this.dropdown.value == \"relative\")\n            return dag_layout_1.AngleOverride.relative(angle);\n        if (this.dropdown.value == \"absolute\")\n            return dag_layout_1.AngleOverride.absolute(angle);\n        if (this.dropdown.value == \"vec-abs\")\n            return dag_layout_1.AngleOverride.vec_abs(this.get_vec());\n        throw new Error(\"Unhandled state.\");\n    };\n    AngleOverrideController.prototype.get_vec = function () {\n        return this.vec_spinner.get_value();\n    };\n    AngleOverrideController.prototype.set_visible = function (bool) {\n        if (bool) {\n            this.base.style.display = \"\";\n        }\n        else {\n            this.base.style.display = \"none\";\n        }\n    };\n    AngleOverrideController.prototype.add_change_listeners = function (listener) {\n        this.change_listeners.push(listener);\n    };\n    AngleOverrideController.prototype.fire_change_listeners = function () {\n        for (var _i = 0, _a = this.change_listeners; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f(this.get_value());\n        }\n    };\n    return AngleOverrideController;\n}());\nexports.AngleOverrideController = AngleOverrideController;\n\n\n//# sourceURL=webpack://dkk/./js_src/subelements/angle_override.js?");

/***/ }),

/***/ "./js_src/subelements/dag_canvas.js":
/*!******************************************!*\
  !*** ./js_src/subelements/dag_canvas.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DAGCanvasContext = exports.DAGCanvas = void 0;\nvar num_1 = __webpack_require__(/*! ../util/num */ \"./js_src/util/num.js\");\nvar DAGCanvas = /** @class */ (function () {\n    function DAGCanvas(canvas, draw_options) {\n        var _this = this;\n        this.canvas = canvas;\n        this.draw_options = draw_options;\n        this.resize_canvas();\n        this.canvas.addEventListener(\"resize\", function (event) {\n            if (_this)\n                _this.resize_canvas();\n        });\n    }\n    DAGCanvas.create = function (draw_options) {\n        var draw_zone = document.createElement(\"canvas\");\n        draw_zone.id = \"draw_zone\";\n        var canvas = new DAGCanvas(draw_zone, draw_options);\n        return {\n            canvas: canvas,\n            element: draw_zone\n        };\n    };\n    DAGCanvas.prototype.resize_canvas = function () {\n        var _a, _b;\n        var pheight = (((_a = this.canvas.parentElement) === null || _a === void 0 ? void 0 : _a.clientHeight) || 2);\n        var pwidth = (((_b = this.canvas.parentElement) === null || _b === void 0 ? void 0 : _b.clientWidth) || 2);\n        this.canvas.style.height = pheight.toString() + \"px\";\n        this.canvas.style.width = pwidth.toString() + \"px\";\n        this.canvas.height = pheight - 2; //-2 to account for border\n        this.canvas.width = pwidth - 2;\n    };\n    DAGCanvas.prototype.get_ctx = function () {\n        return new DAGCanvasContext(this);\n    };\n    DAGCanvas.prototype.get_offset = function () {\n        return new num_1.Vector2(this.canvas.width / 2, this.canvas.height / 2);\n    };\n    DAGCanvas.prototype.local_trans = function (vec) {\n        return vec\n            .scale(this.draw_options.scale())\n            .add(this.get_offset());\n    };\n    DAGCanvas.prototype.local_trans_inv = function (vec) {\n        return vec\n            .sub(this.get_offset())\n            .scale(1 / this.draw_options.scale());\n    };\n    DAGCanvas.prototype.width = function () {\n        return this.canvas.width;\n    };\n    DAGCanvas.prototype.height = function () {\n        return this.canvas.height;\n    };\n    return DAGCanvas;\n}());\nexports.DAGCanvas = DAGCanvas;\nvar DAGCanvasContext = /** @class */ (function () {\n    function DAGCanvasContext(dc) {\n        this.parent = dc;\n        this.ctx = dc.canvas.getContext(\"2d\");\n    }\n    DAGCanvasContext.prototype.clear = function () {\n        this.ctx.clearRect(0, 0, this.parent.canvas.width, this.parent.canvas.height);\n    };\n    DAGCanvasContext.prototype.draw_node = function (pos) {\n        this.draw_circ(pos, this.parent.draw_options.vertex_color(), this.parent.draw_options.vert_radius());\n    };\n    DAGCanvasContext.prototype.draw_circ = function (pos, color, size) {\n        var scaled = this.parent.local_trans(pos);\n        this.ctx.fillStyle = color;\n        this.ctx.beginPath();\n        this.ctx.arc(scaled.x, scaled.y, size, 0, 2 * Math.PI);\n        this.ctx.fill();\n    };\n    DAGCanvasContext.prototype.draw_bez = function (edge, color, weight, halo) {\n        var _this = this;\n        var e = edge.transform(function (v) { return _this.parent.local_trans(v); });\n        this.ctx.beginPath();\n        this.ctx.moveTo(e.start_point.x, e.start_point.y);\n        this.ctx.bezierCurveTo(e.cp1.x, e.cp1.y, e.cp2.x, e.cp2.y, e.end_point.x, e.end_point.y);\n        if (halo) {\n            var grad = this.ctx.createLinearGradient(e.start_point.x, e.start_point.y, e.end_point.x, e.end_point.y);\n            var trans_bk = this.parent.draw_options.background_color() + \"00\"; //Assumes in hex form. \n            var bk = this.parent.draw_options.background_color();\n            grad.addColorStop(0.0, trans_bk);\n            grad.addColorStop(0.3, trans_bk);\n            grad.addColorStop(0.301, bk);\n            grad.addColorStop(0.7, bk);\n            grad.addColorStop(0.701, trans_bk);\n            grad.addColorStop(1.0, trans_bk);\n            this.ctx.strokeStyle = grad;\n            this.ctx.lineWidth = weight + this.parent.draw_options.edge_halo();\n            this.ctx.stroke();\n        }\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = weight;\n        this.ctx.stroke();\n    };\n    DAGCanvasContext.prototype.draw_text = function (text, pos, color, stroke, size) {\n        this.ctx.font = size.toString() + \"px Arial\";\n        this.ctx.fillStyle = color;\n        this.ctx.strokeStyle = stroke;\n        this.ctx.lineWidth = 6;\n        var measure = this.ctx.measureText(text);\n        var scaled = this.parent.local_trans(pos);\n        var position = new num_1.Vector2(scaled.x - measure.width / 2, scaled.y + size / 2 - 2); // + size/2);\n        this.ctx.strokeText(text, position.x, position.y);\n        this.ctx.fillText(text, position.x, position.y);\n    };\n    DAGCanvasContext.prototype.draw_line = function (start, end, color, weight) {\n        var s = this.parent.local_trans(start);\n        var e = this.parent.local_trans(end);\n        this.ctx.beginPath();\n        this.ctx.moveTo(s.x, s.y);\n        this.ctx.lineTo(e.x, e.y);\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = weight;\n        this.ctx.stroke();\n    };\n    DAGCanvasContext.prototype.draw_box = function (top, bot, color) {\n        var t = this.parent.local_trans(top);\n        var b = this.parent.local_trans(bot);\n        var size = b.sub(t);\n        this.ctx.beginPath();\n        this.ctx.rect(t.x, t.y, size.x, size.y);\n        this.ctx.fillStyle = color;\n        this.ctx.fill();\n    };\n    DAGCanvasContext.prototype.draw_rounded_box = function (top, bot, radius, color) {\n        var t = this.parent.local_trans(top);\n        var b = this.parent.local_trans(bot);\n        var size = b.sub(t);\n        this.ctx.beginPath();\n        this.ctx.roundRect(t.x, t.y, size.x, size.y, radius);\n        this.ctx.fillStyle = color;\n        this.ctx.fill();\n    };\n    DAGCanvasContext.prototype.decorate_edges_num = function (dag, baked) {\n        for (var vert = 0; vert < dag.num_verts(); vert++) {\n            var out_frame = dag.get_out_edges(vert).unwrap();\n            for (var edge_idx = 0; edge_idx < out_frame.length; edge_idx++) {\n                var edge = out_frame[edge_idx];\n                var bez = baked.edges[edge];\n                var pos = bez.get_point(0.09);\n                this.draw_text(edge_idx.toString(), pos, \"#ffffff\", \"#000000\", 20);\n            }\n            var in_frame = dag.get_in_edges(vert).unwrap();\n            for (var edge_idx = 0; edge_idx < in_frame.length; edge_idx++) {\n                var edge = in_frame[edge_idx];\n                var bez = baked.edges[edge];\n                var pos = bez.get_point(0.91);\n                this.draw_text(edge_idx.toString(), pos, \"#ffffff\", \"#000000\", 20);\n            }\n        }\n    };\n    DAGCanvasContext.prototype.decorate_edges_arrow = function (baked) {\n        var width = this.parent.draw_options.edge_weight() * 2;\n        for (var edge = 0; edge < baked.edges.length; edge++) {\n            var bez = baked.edges[edge];\n            var direc = bez.get_direc(0.5).normalized().scale(-1);\n            var midway = this.parent.local_trans(bez.get_point(0.5))\n                .add(direc.scale(-width));\n            var p1 = midway\n                .add(direc.scale(width))\n                .add(direc.rot90().scale(width));\n            var p2 = midway\n                .add(direc.scale(width))\n                .add(direc.rot90().scale(-width));\n            this.ctx.fillStyle = this.parent.draw_options.edge_color();\n            this.ctx.beginPath();\n            this.ctx.moveTo(midway.x, midway.y);\n            this.ctx.lineTo(p1.x, p1.y);\n            this.ctx.lineTo(p2.x, p2.y);\n            this.ctx.fill();\n        }\n    };\n    return DAGCanvasContext;\n}());\nexports.DAGCanvasContext = DAGCanvasContext;\n\n\n//# sourceURL=webpack://dkk/./js_src/subelements/dag_canvas.js?");

/***/ }),

/***/ "./js_src/subelements/draw_option_box.js":
/*!***********************************************!*\
  !*** ./js_src/subelements/draw_option_box.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DrawOptionBox = void 0;\nvar SCALE_LOWER = 80;\nvar SCALE_UPPER = 300;\nvar DrawOptionBox = /** @class */ (function () {\n    function DrawOptionBox(box, draw_options) {\n        this.draw_options = draw_options;\n        var scale_slider = this.build_slider(draw_options);\n        this.scale_slider = scale_slider;\n        var table = this.build_table(scale_slider);\n        box.appendChild(table);\n    }\n    DrawOptionBox.create = function (draw_options) {\n        var element = document.createElement(\"div\");\n        element.className = \"sb-subsection\";\n        var box = new DrawOptionBox(element, draw_options);\n        return {\n            box: box,\n            element: element\n        };\n    };\n    DrawOptionBox.prototype.build_slider = function (draw_options) {\n        var scale_slider = document.createElement(\"input\");\n        scale_slider.type = \"range\";\n        scale_slider.className = \"slider\";\n        scale_slider.min = SCALE_LOWER.toString();\n        scale_slider.max = SCALE_UPPER.toString();\n        scale_slider.value = draw_options.scale().toString();\n        scale_slider.oninput = function (ev) {\n            var as_num = Number(scale_slider.value);\n            draw_options.set_scale(as_num);\n        };\n        return scale_slider;\n    };\n    DrawOptionBox.prototype.build_table = function (slider) {\n        var table = document.createElement(\"table\");\n        table.className = \"inputtable\";\n        var data = [\n            { name: \"Scale\", elem: slider },\n        ];\n        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n            var row_data = data_1[_i];\n            var row = document.createElement(\"tr\");\n            table.appendChild(row);\n            var name_1 = document.createElement(\"td\");\n            name_1.innerText = row_data.name;\n            var obj = document.createElement(\"td\");\n            obj.appendChild(row_data.elem);\n            row.appendChild(name_1);\n            row.appendChild(obj);\n        }\n        return table;\n    };\n    return DrawOptionBox;\n}());\nexports.DrawOptionBox = DrawOptionBox;\n\n\n//# sourceURL=webpack://dkk/./js_src/subelements/draw_option_box.js?");

/***/ }),

/***/ "./js_src/subelements/polytope_canvas.js":
/*!***********************************************!*\
  !*** ./js_src/subelements/polytope_canvas.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PolytopeCanvas = void 0;\nvar shaders_1 = __webpack_require__(/*! ./shaders */ \"./js_src/subelements/shaders.js\");\nvar FaceBuffers = /** @class */ (function () {\n    function FaceBuffers(pos_buffer, normal_buffer, simplex_pos_buffer, index_buffer, num_verts) {\n        this.pos_buffer = pos_buffer;\n        this.index_buffer = index_buffer;\n        this.normal_buffer = normal_buffer;\n        this.simplex_pos_buffer = simplex_pos_buffer;\n        this.num_verts = num_verts;\n    }\n    return FaceBuffers;\n}());\nvar PolytopeCanvas = /** @class */ (function () {\n    function PolytopeCanvas(root, draw_options) {\n        var _this = this;\n        this.vertex_positions = [];\n        this.pos_transform = Mat4.id();\n        this.current_clique = null;\n        this.drag = false;\n        this.poly_dim = 0;\n        this.root = root;\n        this.root.id = \"poly-root\";\n        this.draw_options = draw_options;\n        this.canvas = document.createElement(\"canvas\");\n        this.root.appendChild(this.canvas);\n        this.text_overlay = document.createElement(\"div\");\n        this.text_overlay.id = \"poly-canvas-overlay\";\n        this.root.appendChild(this.text_overlay);\n        this.ctx = this.canvas.getContext(\"webgl\");\n        this.external_buffers = new FaceBuffers(this.new_float_buffer([]), this.new_float_buffer([]), this.new_float_buffer([]), this.new_index_buffer([]), 0);\n        this.simpl_buffers = new FaceBuffers(this.new_float_buffer([]), this.new_float_buffer([]), this.new_float_buffer([]), this.new_index_buffer([]), 0);\n        this.dot_buffers = new FaceBuffers(this.new_float_buffer([]), this.new_float_buffer([]), this.new_float_buffer([]), this.new_index_buffer([]), 0);\n        this.program = init_shader_prog(this.ctx);\n        this.resize_canvas();\n        this.canvas.addEventListener(\"resize\", function (event) {\n            _this.resize_canvas();\n        });\n        this.canvas.addEventListener(\"mouseup\", function (ev) { return _this.drag = false; });\n        this.canvas.addEventListener(\"mouseleave\", function (ev) { return _this.drag = false; });\n        this.canvas.addEventListener(\"mousedown\", function (ev) { return _this.drag = true; });\n        this.canvas.addEventListener(\"mousemove\", function (ev) {\n            if (_this.drag)\n                _this.drag_rotate([ev.movementX, -ev.movementY]);\n        });\n    }\n    PolytopeCanvas.create = function (draw_options) {\n        var root = document.createElement(\"div\");\n        var canvas = new PolytopeCanvas(root, draw_options);\n        return {\n            canvas: canvas,\n            element: root\n        };\n    };\n    PolytopeCanvas.prototype.drag_rotate = function (delta) {\n        var x = delta[0], y = delta[1];\n        var d = Math.sqrt(x * x + y * y);\n        if (d < 0.01)\n            return;\n        var theta = Math.min(d / 50, Math.PI / 15);\n        var ax = [-y / d, x / d, 0];\n        var matrix = Mat4.rot_around(ax, theta);\n        this.pos_transform = this.pos_transform.mul(matrix);\n        this.draw();\n    };\n    PolytopeCanvas.prototype.resize_canvas = function () {\n        var _a, _b;\n        var pheight = (((_a = this.root.parentElement) === null || _a === void 0 ? void 0 : _a.clientHeight) || 2);\n        var pwidth = (((_b = this.root.parentElement) === null || _b === void 0 ? void 0 : _b.clientWidth) || 2);\n        this.root.style.height = pheight.toString() + \"px\";\n        this.root.style.width = pwidth.toString() + \"px\";\n        this.canvas.style.height = pheight.toString() + \"px\";\n        this.canvas.style.width = pwidth.toString() + \"px\";\n        this.canvas.height = pheight - 2; //-2 to account for border\n        this.canvas.width = pwidth - 2;\n        this.ctx.viewport(0, 0, this.canvas.width, this.canvas.height);\n    };\n    PolytopeCanvas.prototype.set_polytope = function (poly, current_clique) {\n        var _this = this;\n        this.poly_dim = poly.dim;\n        this.set_message();\n        if (!this.do_render()) {\n            return;\n        }\n        var pad_zeroes = 3 - poly.dim;\n        this.vertex_positions = [];\n        for (var _i = 0, _a = poly.vertices; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            var pad = new Array(pad_zeroes).fill(0);\n            this.vertex_positions.push(structuredClone(pos.coordinates).concat(pad));\n        }\n        var ex_indices = [];\n        var ex_normals = [];\n        var ex_positions = [];\n        var ex_sp = [];\n        var _loop_1 = function (external_tri) {\n            //Somewhat\n            for (var i = 0; i < 3; i++) {\n                ex_indices.push(ex_indices.length);\n            }\n            var get_ex_vert = function (i) {\n                return structuredClone(_this.vertex_positions[external_tri[i]]);\n            };\n            //COMPUTE NORMALS\n            var normal = get_normal(get_ex_vert(0), get_ex_vert(1), get_ex_vert(2), [0, 0, 0]);\n            for (var i = 0; i < 3; i++) {\n                var r = Math.floor(4 * Math.random());\n                var extend = [0, 0, 0, 0];\n                extend[r] = 1;\n                ex_positions = __spreadArray(__spreadArray([], ex_positions, true), this_1.vertex_positions[external_tri[i]], true);\n                ex_normals = __spreadArray(__spreadArray([], ex_normals, true), normal, true);\n                ex_sp = __spreadArray(__spreadArray([], ex_sp, true), extend, true);\n            }\n        };\n        var this_1 = this;\n        for (var _b = 0, _c = poly.external_simplices; _b < _c.length; _b++) {\n            var external_tri = _c[_b];\n            _loop_1(external_tri);\n        }\n        this.external_buffers = new FaceBuffers(this.new_float_buffer(ex_positions), this.new_float_buffer(ex_normals), this.new_float_buffer(ex_sp), this.new_index_buffer(ex_indices), ex_indices.length);\n        this.set_clique(current_clique);\n        this.resize_canvas();\n    };\n    PolytopeCanvas.prototype.set_clique = function (current_clique) {\n        this.current_clique = structuredClone(current_clique);\n        if (!this.do_render()) {\n            return;\n        }\n        //SIMPLICES\n        var sim_indices = [];\n        var sim_normals = [];\n        var sim_positions = [];\n        var sim_simpl_pos = [];\n        var center = [0, 0, 0];\n        for (var j = 0; j < this.poly_dim + 1; j++) {\n            var vert = this.vertex_positions[current_clique.routes[j]];\n            for (var i = 0; i < 3; i++) {\n                center[i] += vert[i] / (this.poly_dim + 1);\n            }\n        }\n        if (this.poly_dim == 3) {\n            for (var excluded_idx = 0; excluded_idx < 4; excluded_idx++) {\n                for (var i = 0; i < 3; i++) {\n                    sim_indices.push(sim_indices.length);\n                }\n                var verts = [];\n                for (var j = 0; j < 4; j++) {\n                    if (j == excluded_idx)\n                        continue;\n                    var vert = this.vertex_positions[current_clique.routes[j]];\n                    verts.push(vert);\n                    var sp = [0, 0, 0, 0];\n                    sp[j] = 1;\n                    var EPS_PLUS_ONE = 1.001;\n                    sim_positions = __spreadArray(__spreadArray([], sim_positions, true), [EPS_PLUS_ONE * vert[0], EPS_PLUS_ONE * vert[1], EPS_PLUS_ONE * vert[2]], false);\n                    sim_simpl_pos = __spreadArray(__spreadArray([], sim_simpl_pos, true), sp, true);\n                }\n                var normal = get_normal(verts[0], verts[1], verts[2], center);\n                for (var i = 0; i < 3; i++)\n                    sim_normals = __spreadArray(__spreadArray([], sim_normals, true), normal, true);\n            }\n        }\n        else if (this.poly_dim == 2) {\n            for (var i = 0; i < 6; i++) {\n                sim_indices.push(sim_indices.length);\n            }\n            var base_verts = [];\n            for (var j = 0; j < 3; j++) {\n                var vert = this.vertex_positions[current_clique.routes[j]];\n                base_verts.push(vert);\n            }\n            var EPS_PLUS_ONE_1 = 1.001;\n            var _loop_2 = function (orient) {\n                var transform = function (v) {\n                    return [\n                        v[0] * EPS_PLUS_ONE_1,\n                        v[1] * EPS_PLUS_ONE_1,\n                        (v[2] + 0.001 * orient) * EPS_PLUS_ONE_1\n                    ];\n                };\n                var verts = base_verts.map(transform);\n                sim_positions = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], sim_positions, true), verts[0], true), verts[1], true), verts[2], true);\n                sim_simpl_pos = __spreadArray(__spreadArray([], sim_simpl_pos, true), [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], false);\n                var normal = get_normal(verts[0], verts[1], verts[2], center);\n                for (var i = 0; i < 3; i++)\n                    sim_normals = __spreadArray(__spreadArray([], sim_normals, true), structuredClone(normal), true);\n            };\n            for (var orient = -1; orient < 2; orient += 2) {\n                _loop_2(orient);\n            }\n        }\n        else {\n            console.warn(\"set_clique reached state that should be unreachable.\");\n        }\n        this.simpl_buffers = new FaceBuffers(this.new_float_buffer(sim_positions), this.new_float_buffer(sim_normals), this.new_float_buffer(sim_simpl_pos), this.new_index_buffer(sim_indices), sim_indices.length);\n        //DOTS\n        var dot_indices = [];\n        var dot_normals = [];\n        var dot_positions = [];\n        var dot_simpl_pos = [];\n        var sphere = gen_sphere(10, 10, this.draw_options.dot_radius() / 100);\n        for (var j = 0; j < this.poly_dim + 1; j++) {\n            var center_1 = this.vertex_positions[current_clique.routes[j]];\n            var base = sphere.positions.length * j;\n            for (var _i = 0, _a = sphere.idxs; _i < _a.length; _i++) {\n                var idx = _a[_i];\n                dot_indices.push(base + idx);\n            }\n            var simpl = [0, 0, 0, 0];\n            simpl[j] = 1;\n            for (var _b = 0, _c = sphere.positions; _b < _c.length; _b++) {\n                var pos = _c[_b];\n                var offset_pos = [\n                    center_1[0] + pos[0],\n                    center_1[1] + pos[1],\n                    center_1[2] + pos[2]\n                ];\n                dot_positions = __spreadArray(__spreadArray([], dot_positions, true), offset_pos, true);\n                dot_simpl_pos = __spreadArray(__spreadArray([], dot_simpl_pos, true), simpl, true);\n            }\n            for (var _d = 0, _e = sphere.normals; _d < _e.length; _d++) {\n                var norm = _e[_d];\n                dot_normals = __spreadArray(__spreadArray([], dot_normals, true), norm, true);\n            }\n        }\n        this.dot_buffers = new FaceBuffers(this.new_float_buffer(dot_positions), this.new_float_buffer(dot_normals), this.new_float_buffer(dot_simpl_pos), this.new_index_buffer(dot_indices), dot_indices.length);\n    };\n    PolytopeCanvas.prototype.set_message = function () {\n        this.text_overlay.innerText = \"Polytope dimension: \" + this.poly_dim.toString();\n    };\n    PolytopeCanvas.prototype.new_float_buffer = function (arr) {\n        var buf = this.ctx.createBuffer();\n        this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, buf);\n        this.ctx.bufferData(this.ctx.ARRAY_BUFFER, new Float32Array(arr), this.ctx.STATIC_DRAW);\n        return buf;\n    };\n    PolytopeCanvas.prototype.new_index_buffer = function (arr) {\n        var buf = this.ctx.createBuffer();\n        this.ctx.bindBuffer(this.ctx.ELEMENT_ARRAY_BUFFER, buf);\n        this.ctx.bufferData(this.ctx.ELEMENT_ARRAY_BUFFER, new Uint16Array(arr), this.ctx.STATIC_DRAW);\n        return buf;\n    };\n    PolytopeCanvas.prototype.draw = function () {\n        var _this = this;\n        this.ctx.clearDepth(1.0);\n        this.ctx.clearColor(0, 0, 0, 1);\n        if (!this.do_render())\n            return;\n        this.ctx.enable(this.ctx.DEPTH_TEST);\n        this.ctx.depthFunc(this.ctx.LEQUAL);\n        this.ctx.useProgram(this.program.program);\n        this.bind_transform_uniforms();\n        this.bind_simplex_colors();\n        this.ctx.enable(this.ctx.BLEND);\n        this.ctx.blendFunc(this.ctx.SRC_ALPHA, this.ctx.ONE_MINUS_SRC_ALPHA);\n        var draw_dots = function () {\n            if (_this.draw_options.simplex_render_mode() == \"dots\") {\n                if (_this.draw_options.dot_on_top()) {\n                    _this.ctx.clear(_this.ctx.DEPTH_BUFFER_BIT);\n                }\n                _this.bind_face_buffers(_this.dot_buffers);\n                _this.ctx.uniform1f(_this.program.uniforms.cull_dir, 0);\n                _this.ctx.uniform1f(_this.program.uniforms.transparency, 1.0);\n                _this.ctx.uniform1f(_this.program.uniforms.do_simplex_color, 1);\n                var shade_amount = 0;\n                if (_this.draw_options.dot_shade())\n                    shade_amount = 1;\n                _this.ctx.uniform1f(_this.program.uniforms.shade_amount, shade_amount);\n                var color = [1, 0, 0]; //If this color shows, something is broken\n                _this.ctx.uniform3fv(_this.program.uniforms.color, color);\n                var triangle_count = _this.dot_buffers.num_verts;\n                var type = _this.ctx.UNSIGNED_SHORT;\n                var offset = 0;\n                _this.ctx.drawElements(_this.ctx.TRIANGLES, triangle_count, type, offset);\n            }\n        };\n        var draw_external = function (dir) {\n            _this.bind_face_buffers(_this.external_buffers);\n            _this.ctx.uniform1f(_this.program.uniforms.cull_dir, dir);\n            _this.ctx.uniform1f(_this.program.uniforms.transparency, 0.5);\n            _this.ctx.uniform1f(_this.program.uniforms.do_simplex_color, -1);\n            _this.ctx.uniform1f(_this.program.uniforms.shade_amount, 1);\n            if (_this.poly_dim == 2) {\n                _this.ctx.uniform1f(_this.program.uniforms.shade_amount, 0);\n            }\n            var color_i = css_str_to_rgb(_this.draw_options.polytope_color());\n            var color = [\n                color_i[0] / 255,\n                color_i[1] / 255,\n                color_i[2] / 255\n            ];\n            if (dir == -1) {\n                color[0] *= 0.5;\n                color[1] *= 0.5;\n                color[2] *= 0.5;\n            }\n            _this.ctx.uniform3fv(_this.program.uniforms.color, color);\n            var triangle_count = _this.external_buffers.num_verts;\n            var type = _this.ctx.UNSIGNED_SHORT;\n            var offset = 0;\n            _this.ctx.drawElements(_this.ctx.TRIANGLES, triangle_count, type, offset);\n        };\n        draw_dots();\n        draw_external(-1);\n        {\n            this.bind_face_buffers(this.simpl_buffers);\n            this.ctx.uniform1f(this.program.uniforms.cull_dir, 1);\n            this.ctx.uniform1f(this.program.uniforms.transparency, 1.0);\n            this.ctx.uniform1f(this.program.uniforms.do_simplex_color, 1);\n            var simpl_mode = this.draw_options.simplex_render_mode();\n            if (simpl_mode == \"blank\" || simpl_mode == \"dots\")\n                this.ctx.uniform1f(this.program.uniforms.do_simplex_color, 0);\n            this.ctx.uniform1f(this.program.uniforms.shade_amount, 1);\n            var color_i = css_str_to_rgb(this.draw_options.simplex_color());\n            var color = [\n                color_i[0] / 255,\n                color_i[1] / 255,\n                color_i[2] / 255\n            ];\n            this.ctx.uniform3fv(this.program.uniforms.color, color);\n            var triangle_count = this.simpl_buffers.num_verts;\n            var type = this.ctx.UNSIGNED_SHORT;\n            var offset = 0;\n            this.ctx.drawElements(this.ctx.TRIANGLES, triangle_count, type, offset);\n        }\n        draw_external(1);\n        draw_dots();\n    };\n    PolytopeCanvas.prototype.bind_face_buffers = function (face_buffers) {\n        //Position\n        this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, face_buffers.pos_buffer);\n        this.ctx.vertexAttribPointer(this.program.attribs.vertex_pos, 3, this.ctx.FLOAT, false, 0, 0);\n        this.ctx.enableVertexAttribArray(this.program.attribs.vertex_pos);\n        //normal\n        this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, face_buffers.normal_buffer);\n        this.ctx.vertexAttribPointer(this.program.attribs.vertex_normal, 3, this.ctx.FLOAT, false, 0, 0);\n        this.ctx.enableVertexAttribArray(this.program.attribs.vertex_normal);\n        //Simplex pos\n        this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, face_buffers.simplex_pos_buffer);\n        this.ctx.vertexAttribPointer(this.program.attribs.simplex_pos, 4, this.ctx.FLOAT, false, 0, 0);\n        this.ctx.enableVertexAttribArray(this.program.attribs.simplex_pos);\n        //Index\n        this.ctx.bindBuffer(this.ctx.ELEMENT_ARRAY_BUFFER, face_buffers.index_buffer);\n    };\n    PolytopeCanvas.prototype.bind_transform_uniforms = function () {\n        var wid = this.canvas.width;\n        var hei = this.canvas.height;\n        var wmod = wid / hei;\n        var hmod = 1;\n        if (wid > hei) {\n            hmod = hei / wid;\n            wmod = 1;\n        }\n        this.ctx.uniformMatrix4fv(this.program.uniforms.view_matrix, false, [\n            hmod, 0, 0, 0,\n            0, wmod, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n        ]);\n        this.ctx.uniformMatrix4fv(this.program.uniforms.position_matrix, false, this.pos_transform.flat_arr());\n    };\n    PolytopeCanvas.prototype.bind_simplex_colors = function () {\n        var mat = [\n            0.792, 0.913, 0.960, 1,\n            0.792, 0.913, 0.960, 1,\n            0.792, 0.913, 0.960, 1,\n            0.792, 0.913, 0.960, 1\n        ];\n        var colors = [0, 1, 2, 3];\n        if (this.current_clique) {\n            colors = this.current_clique.routes;\n        }\n        else {\n            console.warn(\"No current clique; coloring will be arbitrary.\");\n        }\n        for (var i = 0; i < colors.length; i++) {\n            var c_idx = colors[i];\n            var col = this.draw_options.get_route_color(c_idx);\n            var col_arr = css_str_to_rgb(col);\n            for (var j = 0; j < 3; j++) {\n                mat[4 * i + j] = col_arr[j] / 255;\n            }\n        }\n        this.ctx.uniformMatrix4fv(this.program.uniforms.simplex_colors, false, mat);\n    };\n    PolytopeCanvas.prototype.do_render = function () {\n        return this.poly_dim == 2 || this.poly_dim == 3;\n    };\n    return PolytopeCanvas;\n}());\nexports.PolytopeCanvas = PolytopeCanvas;\nfunction load_shader(ctx, type, src) {\n    var shader = ctx.createShader(type);\n    ctx.shaderSource(shader, src);\n    ctx.compileShader(shader);\n    if (!ctx.getShaderParameter(shader, ctx.COMPILE_STATUS)) {\n        alert(\"An error occurred compiling the shaders: \".concat(ctx.getShaderInfoLog(shader)));\n    }\n    return shader;\n}\nfunction init_shader_prog(ctx) {\n    var vert_shader = load_shader(ctx, ctx.VERTEX_SHADER, shaders_1.VERT_SHADER);\n    var frag_shader = load_shader(ctx, ctx.FRAGMENT_SHADER, shaders_1.EXTERNAL_FRAG_SHADER);\n    // Create the shader program\n    var shader_program = ctx.createProgram();\n    ctx.attachShader(shader_program, vert_shader);\n    ctx.attachShader(shader_program, frag_shader);\n    ctx.linkProgram(shader_program);\n    if (!ctx.getProgramParameter(shader_program, ctx.LINK_STATUS)) {\n        alert(\"Unable to initialize the shader program: \".concat(ctx.getProgramInfoLog(shader_program)));\n    }\n    return {\n        program: shader_program,\n        attribs: {\n            vertex_pos: ctx.getAttribLocation(shader_program, \"vertex_pos\"),\n            vertex_normal: ctx.getAttribLocation(shader_program, \"vertex_normal\"),\n            simplex_pos: ctx.getAttribLocation(shader_program, \"simplex_pos\")\n        },\n        uniforms: {\n            view_matrix: ctx.getUniformLocation(shader_program, \"view_matrix\"),\n            position_matrix: ctx.getUniformLocation(shader_program, \"position_matrix\"),\n            cull_dir: ctx.getUniformLocation(shader_program, \"cull_dir\"),\n            color: ctx.getUniformLocation(shader_program, \"color\"),\n            transparency: ctx.getUniformLocation(shader_program, \"transparency\"),\n            simplex_colors: ctx.getUniformLocation(shader_program, \"simplex_colors\"),\n            do_simplex_color: ctx.getUniformLocation(shader_program, \"do_simplex_color\"),\n            shade_amount: ctx.getUniformLocation(shader_program, \"shade_amount\"),\n        }\n    };\n}\nvar Mat4 = /** @class */ (function () {\n    function Mat4(inner) {\n        this.inner = inner;\n    }\n    Mat4.id = function () {\n        return new Mat4([\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ]);\n    };\n    Mat4.zero_arr = function () {\n        return [\n            [0, 0, 0, 0],\n            [0, 0, 0, 0],\n            [0, 0, 0, 0],\n            [0, 0, 0, 0]\n        ];\n    };\n    Mat4.prototype.flat_arr = function () {\n        var out = [];\n        for (var _i = 0, _a = this.inner; _i < _a.length; _i++) {\n            var row = _a[_i];\n            out = __spreadArray(__spreadArray([], out, true), row, true);\n        }\n        return out;\n    };\n    Mat4.prototype.mul = function (other) {\n        var out = Mat4.zero_arr();\n        for (var i = 0; i < 4; i++)\n            for (var j = 0; j < 4; j++)\n                for (var k = 0; k < 4; k++)\n                    out[i][j] += this.inner[i][k] * other.inner[k][j];\n        return new Mat4(out);\n    };\n    Mat4.rot_around = function (unit_ax, theta) {\n        var c = Math.cos(theta);\n        var s = Math.sin(theta);\n        var ux = unit_ax[0], uy = unit_ax[1], uz = unit_ax[2];\n        return new Mat4([\n            [c + ux * ux * (1 - c), ux * uy * (1 - c) - uz * s, ux * uz * (1 - c) + uy * s, 0],\n            [uy * ux * (1 - c) + uz * s, c + uy * uy * (1 - c), uy * uz * (1 - c) - ux * s, 0],\n            [uz * ux * (1 - c) - uy * s, uz * uy * (1 - c) + ux * s, c + uz * uz * (1 - c), 0],\n            [0, 0, 0, 1]\n        ]);\n    };\n    return Mat4;\n}());\nfunction css_str_to_rgb(css_str) {\n    var start = css_str.slice(0, 1);\n    if (start == \"#\") {\n        var num = Number(\"0x\" + css_str.slice(1));\n        return [\n            (num >> 16) & 255,\n            (num >> 8) & 255,\n            num & 255\n        ];\n    }\n    else if (start = \"r\") {\n        var comps = css_str.match(/\\d+/g);\n        return [\n            Number(comps[0]),\n            Number(comps[1]),\n            Number(comps[2]),\n        ];\n    }\n    console.warn(\"Unknown color string format! \", css_str);\n    return [255, 255, 255];\n}\nfunction get_normal(p1, p2, p3, center) {\n    var root = p1;\n    var arm1 = [p2[0] - root[0], p2[1] - root[1], p2[2] - root[2]];\n    var arm2 = [p3[0] - root[0], p3[1] - root[1], p3[2] - root[2]];\n    var normal = cross_product(arm1, arm2);\n    var dot = 0;\n    for (var i = 0; i < 3; i++)\n        dot += normal[i] * (root[i] - center[i]);\n    if (dot > 0)\n        for (var i = 0; i < 3; i++)\n            normal[i] *= -1;\n    return normal;\n}\nfunction cross_product(a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n}\nfunction gen_sphere(rows, cols, radius) {\n    var sphere = [];\n    var idx = [];\n    var normals = [];\n    for (var row = 0; row < rows; row++) {\n        for (var col = 0; col < cols; col++) {\n            var vangle = row * Math.PI / (rows - 1);\n            var hangle = col * 2 * Math.PI / cols;\n            var sv = Math.sin(vangle);\n            var cv = Math.cos(vangle);\n            var sh = Math.sin(hangle);\n            var ch = Math.cos(hangle);\n            var vert = [ch * sv * radius, cv * radius, sh * sv * radius];\n            var normal = [-ch * sv, -cv, -sh * sv];\n            sphere.push(vert);\n            normals.push(normal);\n        }\n    }\n    var vert_idx = function (row, col) { return row * cols + (col % cols); };\n    for (var row = 0; row < rows - 1; row++) {\n        for (var col = 0; col < cols; col++) {\n            var p1 = vert_idx(row, col);\n            var p2 = vert_idx(row + 1, col);\n            var p3 = vert_idx(row, col + 1);\n            var p4 = vert_idx(row + 1, col + 1);\n            idx = __spreadArray(__spreadArray([], idx, true), [p1, p2, p4, p1, p3, p4], false);\n        }\n    }\n    return { positions: sphere, idxs: idx, normals: normals };\n}\n\n\n//# sourceURL=webpack://dkk/./js_src/subelements/polytope_canvas.js?");

/***/ }),

/***/ "./js_src/subelements/shaders.js":
/*!***************************************!*\
  !*** ./js_src/subelements/shaders.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VERT_SHADER = exports.EXTERNAL_FRAG_SHADER = void 0;\nexports.EXTERNAL_FRAG_SHADER = \"\\nprecision mediump float;\\n\\nvarying highp vec3 v_normal;\\nvarying highp vec3 v_pos;\\nvarying highp vec4 v_simplex_pos;\\n\\nconst highp vec3 LIGHT_DIR = normalize(vec3(-1,1,-1));\\n\\nuniform float cull_dir;\\nuniform float transparency;\\nuniform vec3 color;\\nuniform mat4 simplex_colors;\\nuniform float do_simplex_color;\\nuniform float shade_amount;\\n\\nvoid main() {\\n    if(cull_dir * v_normal.z < 0.0)\\n    {\\n        discard;\\n    }\\n\\n    vec3 true_color = color;\\n    if(do_simplex_color > 0.0)\\n    {\\n        float mx = max(max(max(v_simplex_pos.x, v_simplex_pos.y), v_simplex_pos.z), v_simplex_pos.w);\\n        if(mx == v_simplex_pos.x)\\n        {\\n            true_color = simplex_colors[0].xyz;\\n        }\\n        else if(mx == v_simplex_pos.y)\\n        {\\n            true_color = simplex_colors[1].xyz;\\n        }\\n        else if(mx == v_simplex_pos.z)\\n        {\\n            true_color = simplex_colors[2].xyz;\\n        }\\n        else\\n        {\\n            true_color = simplex_colors[3].xyz;\\n        }\\n    }\\n\\n    float light_direct = 0.7 * clamp(-dot(LIGHT_DIR, v_normal), 0.0, 1.0);\\n    float light_ambient = 0.3;\\n\\n    vec3 light = (shade_amount * (light_direct + light_ambient) * true_color) + (1.0 - shade_amount) * true_color;\\n\\n    gl_FragColor = vec4(light, transparency);\\n}\\n\";\nexports.VERT_SHADER = \"\\nattribute vec4 vertex_pos;\\nattribute vec3 vertex_normal;\\nattribute vec4 simplex_pos;\\n\\nvarying highp vec3 v_normal;\\nvarying highp vec3 v_pos;\\nvarying highp vec4 v_simplex_pos;\\n\\nuniform mat4 position_matrix;\\nuniform mat4 view_matrix;\\n\\n\\nvoid main() {\\n    gl_Position = view_matrix * position_matrix * vertex_pos;\\n    v_normal = (position_matrix * vec4(vertex_normal,1)).xyz;\\n    v_pos = vertex_pos.xyz;\\n    v_simplex_pos = simplex_pos;\\n}\\n\";\n\n\n//# sourceURL=webpack://dkk/./js_src/subelements/shaders.js?");

/***/ }),

/***/ "./js_src/subelements/swap_box.js":
/*!****************************************!*\
  !*** ./js_src/subelements/swap_box.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SwapBox = void 0;\nvar SwapBox = /** @class */ (function () {\n    function SwapBox(main_box, on_click, draw_options, clique_size) {\n        var _this = this;\n        this.draw_options = draw_options;\n        this.on_click = on_click;\n        var boxes = [];\n        var color_idxs = [];\n        var _loop_1 = function (i) {\n            var box = document.createElement(\"div\");\n            var idx = i + 0;\n            box.onclick = function () {\n                _this.on_click(_this.route_idxs[idx]);\n            };\n            box.className = \"swap_button\";\n            box.innerHTML = \"<div class=\\\"swap-dot\\\"/>\";\n            main_box.appendChild(box);\n            boxes.push(box);\n            color_idxs.push(0);\n        };\n        for (var i = 0; i < clique_size; i++) {\n            _loop_1(i);\n        }\n        this.boxes = boxes;\n        this.route_idxs = color_idxs;\n    }\n    SwapBox.create = function (on_click, draw_options, clique_size) {\n        var element = document.createElement(\"div\");\n        element.className = \"sb-subsection\";\n        var box = new SwapBox(element, on_click, draw_options, clique_size);\n        return {\n            box: box,\n            element: element\n        };\n    };\n    SwapBox.prototype.set_color = function (box_idx, color_idx) {\n        this.route_idxs[box_idx] = color_idx;\n        this.update_color();\n    };\n    SwapBox.prototype.swap_color = function (old_color_idx, new_color_idx) {\n        for (var i = 0; i < this.route_idxs.length; i++) {\n            if (this.route_idxs[i] == old_color_idx) {\n                this.route_idxs[i] = new_color_idx;\n                this.update_color();\n                return;\n            }\n        }\n        console.warn(\"Failed to swap color!\");\n    };\n    SwapBox.prototype.update_color = function () {\n        for (var i = 0; i < this.boxes.length; i++) {\n            this.boxes[i].style.backgroundColor =\n                this.draw_options.get_route_color(this.route_idxs[i]);\n        }\n    };\n    SwapBox.prototype.show_enabled = function (route_idx, enabled) {\n        var i = this.route_idxs.indexOf(route_idx);\n        if (i === -1) {\n            console.warn(\"Tried to show_enabled invalid index.\");\n            return;\n        }\n        var box = this.boxes[i];\n        box.classList.remove(\"swap-greyed\");\n        if (!enabled) {\n            box.classList.add(\"swap-greyed\");\n        }\n    };\n    return SwapBox;\n}());\nexports.SwapBox = SwapBox;\n\n\n//# sourceURL=webpack://dkk/./js_src/subelements/swap_box.js?");

/***/ }),

/***/ "./js_src/subelements/vec_spinner.js":
/*!*******************************************!*\
  !*** ./js_src/subelements/vec_spinner.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VecSpinner = void 0;\nvar num_1 = __webpack_require__(/*! ../util/num */ \"./js_src/util/num.js\");\nvar VecSpinner = /** @class */ (function () {\n    function VecSpinner() {\n        var _this = this;\n        this.change_listeners = [];\n        this.base = document.createElement(\"div\");\n        this.base.className = \"vec-spinner\";\n        this.spinner1 = document.createElement(\"input\");\n        this.spinner2 = document.createElement(\"input\");\n        for (var _i = 0, _a = [this.spinner1, this.spinner2]; _i < _a.length; _i++) {\n            var spn = _a[_i];\n            spn.type = \"number\";\n            spn.value = \"0\";\n            spn.step = \"0.05\";\n        }\n        this.base.appendChild(this.spinner1);\n        this.base.appendChild(this.spinner2);\n        this.spinner1.addEventListener(\"change\", function (v) { return _this.fire_change_listeners(); });\n        this.spinner2.addEventListener(\"change\", function (v) { return _this.fire_change_listeners(); });\n    }\n    VecSpinner.prototype.set_visible = function (bool) {\n        if (bool) {\n            this.base.style.display = \"\";\n        }\n        else {\n            this.base.style.display = \"none\";\n        }\n    };\n    VecSpinner.prototype.get_value = function () {\n        return new num_1.Vector2(parseFloat(this.spinner1.value), -parseFloat(this.spinner2.value));\n    };\n    VecSpinner.prototype.set_value = function (v) {\n        this.spinner1.value = v.x.toString();\n        this.spinner2.value = (-v.y).toString();\n    };\n    VecSpinner.prototype.add_change_listeners = function (listener) {\n        this.change_listeners.push(listener);\n    };\n    VecSpinner.prototype.fire_change_listeners = function () {\n        for (var _i = 0, _a = this.change_listeners; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f(this.get_value());\n        }\n    };\n    return VecSpinner;\n}());\nexports.VecSpinner = VecSpinner;\n\n\n//# sourceURL=webpack://dkk/./js_src/subelements/vec_spinner.js?");

/***/ }),

/***/ "./js_src/util/cookie.js":
/*!*******************************!*\
  !*** ./js_src/util/cookie.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\nCode stolen from\nhttps://www.slingacademy.com/article/set-and-get-browser-cookies-with-typescript-basic-and-advanced-examples/\nWhy is the javascript cookie API so cursed? Why do I have to format a string to access basic functionality?\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.set_cookie = set_cookie;\nexports.get_cookie = get_cookie;\nfunction set_cookie(name, value, days) {\n    var expires = \"\";\n    if (days) {\n        var date = new Date();\n        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n        expires = \"; expires=\" + date.toUTCString();\n    }\n    document.cookie = name + \"=\" + value + expires + \"; path=/ ;SameSite=Lax\";\n}\nfunction get_cookie(name) {\n    var nameEQ = name + \"=\";\n    var ca = document.cookie.split(';');\n    for (var i = 0; i < ca.length; i++) {\n        var c = ca[i].trim();\n        if (c.indexOf(nameEQ) == 0)\n            return c.substring(nameEQ.length, c.length);\n    }\n    return null;\n}\n\n\n//# sourceURL=webpack://dkk/./js_src/util/cookie.js?");

/***/ }),

/***/ "./js_src/util/num.js":
/*!****************************!*\
  !*** ./js_src/util/num.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clamp = exports.BoundingBox = exports.Bezier = exports.Vector2 = void 0;\nvar Vector2 = /** @class */ (function () {\n    function Vector2(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    Vector2.zero = function () {\n        return new Vector2(0, 0);\n    };\n    Vector2.prototype.scale = function (s) {\n        return new Vector2(this.x * s, this.y * s);\n    };\n    Vector2.prototype.add = function (v) {\n        return new Vector2(this.x + v.x, this.y + v.y);\n    };\n    Vector2.prototype.sub = function (v) {\n        return new Vector2(this.x - v.x, this.y - v.y);\n    };\n    Vector2.prototype.rot90 = function () {\n        return new Vector2(-this.y, this.x);\n    };\n    Vector2.prototype.rot = function (d) {\n        return new Vector2(this.x * Math.cos(d) - this.y * Math.sin(d), this.x * Math.sin(d) + this.y * Math.cos(d));\n    };\n    Vector2.prototype.norm = function () {\n        return Math.sqrt(this.x * this.x +\n            this.y * this.y);\n    };\n    Vector2.prototype.normalized = function () {\n        var n = this.norm();\n        if (Math.abs(n) < 0.00000000001) {\n            console.warn(\"Tried to normalize zero vector.\");\n            return Vector2.zero();\n        }\n        return this.scale(1 / n);\n    };\n    Vector2.prototype.transform = function (m) {\n        var c1 = new Vector2(m[0][0], m[1][0]);\n        var c2 = new Vector2(m[0][1], m[1][1]);\n        return c1.scale(this.x).add(c2.scale(this.y));\n    };\n    Vector2.prototype.clone = function () {\n        return new Vector2(this.x, this.y);\n    };\n    Vector2.right = function () {\n        return new Vector2(1, 0);\n    };\n    Vector2.prototype.min = function (other) {\n        return new Vector2(Math.min(this.x, other.x), Math.min(this.y, other.y));\n    };\n    Vector2.prototype.max = function (other) {\n        return new Vector2(Math.max(this.x, other.x), Math.max(this.y, other.y));\n    };\n    return Vector2;\n}());\nexports.Vector2 = Vector2;\nvar Bezier = /** @class */ (function () {\n    function Bezier(st, cp1, cp2, end) {\n        this.start_point = st;\n        this.end_point = end,\n            this.cp1 = cp1;\n        this.cp2 = cp2;\n    }\n    Bezier.prototype.transform = function (trans) {\n        return new Bezier(trans(this.start_point), trans(this.cp1), trans(this.cp2), trans(this.end_point));\n    };\n    Bezier.prototype.get_direc = function (t) {\n        var it = 1 - t;\n        return this.start_point.scale(-3 * it * it)\n            .add(this.cp1.scale(3 * (1 - 3 * t) * it))\n            .add(this.cp2.scale(3 * (2 - 3 * t) * t))\n            .add(this.end_point.scale(3 * t * t));\n    };\n    Bezier.prototype.get_point = function (t) {\n        var it = 1 - t;\n        return this.start_point.scale(it * it * it)\n            .add(this.cp1.scale(3 * t * it * it))\n            .add(this.cp2.scale(3 * t * t * it))\n            .add(this.end_point.scale(t * t * t));\n    };\n    Bezier.prototype.distance_to = function (position) {\n        var _this = this;\n        var EPSILON = 0.001;\n        var STEP = 0.02;\n        var dist = function (t) { return _this.get_point(t).sub(position).norm(); };\n        var d_dist = function (t) { return (dist(t + EPSILON) - dist(t)) / EPSILON; };\n        var min_t = 0;\n        var min_dst = dist(0);\n        for (var _i = 0, _a = [0, 0.2, 0.4, 0.6, 0.8, 1.0]; _i < _a.length; _i++) {\n            var tp = _a[_i];\n            var d = dist(tp);\n            if (d < min_dst) {\n                min_t = tp;\n                min_dst = d;\n            }\n        }\n        var low = (0, exports.clamp)(min_t - 0.2, 0, 1);\n        var high = (0, exports.clamp)(min_t + 0.2, 0, 1);\n        for (var i = 0; i < 8; i++) {\n            var mid = (low + high) / 2;\n            var dl = d_dist(low);\n            var dm = d_dist(mid);\n            if (dl * dm < 0) {\n                high = mid;\n            }\n            else {\n                low = mid;\n            }\n        }\n        return dist((low + high) / 2);\n    };\n    return Bezier;\n}());\nexports.Bezier = Bezier;\nvar BoundingBox = /** @class */ (function () {\n    function BoundingBox(vecs) {\n        this.empty = true;\n        this.top_corner = Vector2.zero();\n        this.bot_corner = Vector2.zero();\n        for (var _i = 0, vecs_1 = vecs; _i < vecs_1.length; _i++) {\n            var v = vecs_1[_i];\n            this.add_point(v);\n        }\n    }\n    BoundingBox.prototype.add_point = function (v) {\n        if (this.empty) {\n            this.empty = false;\n            this.top_corner = v;\n            this.bot_corner = v;\n        }\n        else {\n            this.top_corner = this.top_corner.min(v);\n            this.bot_corner = this.bot_corner.max(v);\n        }\n    };\n    BoundingBox.prototype.pad = function (w) {\n        var delta = new Vector2(w, w);\n        this.top_corner = this.top_corner.sub(delta);\n        this.bot_corner = this.bot_corner.add(delta);\n    };\n    BoundingBox.prototype.extent = function () {\n        var x = Math.max(Math.abs(this.top_corner.x), Math.abs(this.bot_corner.x));\n        var y = Math.max(Math.abs(this.top_corner.y), Math.abs(this.bot_corner.y));\n        return new Vector2(x, y);\n    };\n    return BoundingBox;\n}());\nexports.BoundingBox = BoundingBox;\nvar clamp = function (num, min, max) { return Math.min(Math.max(num, min), max); };\nexports.clamp = clamp;\n\n\n//# sourceURL=webpack://dkk/./js_src/util/num.js?");

/***/ }),

/***/ "./js_src/util/result.js":
/*!*******************************!*\
  !*** ./js_src/util/result.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n    Implementation of Rust-style errors, because those are nicer.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Option = exports.Result = void 0;\nvar Result = /** @class */ (function () {\n    function Result(success, ok, err) {\n        this.ok = undefined;\n        this.err = undefined;\n        this.success = success;\n        if (success) {\n            if (typeof ok === \"undefined\") {\n                throw new Error(\"Invalid result construction, 'ok' undefined on success.\");\n            }\n            this.ok = ok;\n        }\n        else {\n            if (typeof err === \"undefined\") {\n                throw new Error(\"Invalid result construction, 'err' undefined on failure.\");\n            }\n            this.err = err;\n        }\n    }\n    Result.ok = function (t) {\n        return new Result(true, t, undefined);\n    };\n    Result.err = function (err_name, err_message) {\n        var err = {\n            err_message: err_message,\n            err_name: err_name\n        };\n        return new Result(false, undefined, err);\n    };\n    Result.prototype.unwrap = function () {\n        var _a, _b;\n        if (!this.success) {\n            throw new Error(\"Tried to unwrap failed Result.\\nError: \" + ((_a = this.err) === null || _a === void 0 ? void 0 : _a.err_name) + \"\\nMessage: \" + ((_b = this.err) === null || _b === void 0 ? void 0 : _b.err_message));\n        }\n        return this.ok;\n    };\n    Result.prototype.unwrap_or = function (val) {\n        if (this.success) {\n            return this.ok;\n        }\n        return val;\n    };\n    Result.prototype.unwrap_or_null = function () {\n        if (this.success) {\n            return this.ok;\n        }\n        return null;\n    };\n    Result.prototype.is_ok = function () {\n        return this.success;\n    };\n    Result.prototype.is_err = function () {\n        return !this.success;\n    };\n    Result.prototype.error = function () {\n        if (this.success) {\n            throw new Error(\"Tried to unwrap error from successful Result.\");\n        }\n        return this.err;\n    };\n    Result.prototype.map = function (fn) {\n        if (this.success) {\n            var new_ok = fn(this.ok);\n            return Result.ok(new_ok);\n        }\n        else {\n            var err = this.err;\n            return new Result(false, undefined, err);\n        }\n    };\n    Result.prototype.err_to_err = function () {\n        if (this.success) {\n            throw new Error(\"Tried to unwrap error from successful Result.\");\n        }\n        var err = this.err;\n        return new Result(false, undefined, err);\n    };\n    return Result;\n}());\nexports.Result = Result;\nvar Option = /** @class */ (function () {\n    function Option(valid, some) {\n        this.valid = valid;\n        if (valid) {\n            if (typeof some === \"undefined\") {\n                throw new Error(\"Invalid result construction, 'ok' undefined on success.\");\n            }\n            this.value = some;\n        }\n        else {\n            this.value = undefined;\n        }\n    }\n    Option.some = function (t) {\n        return new Option(true, t);\n    };\n    Option.none = function () {\n        return new Option(false, undefined);\n    };\n    Option.prototype.unwrap = function () {\n        if (!this.valid) {\n            throw new Error(\"Tried to unwrap None.\");\n        }\n        return this.value;\n    };\n    Option.prototype.unwrap_or = function (val) {\n        if (this.valid) {\n            return this.value;\n        }\n        return val;\n    };\n    Option.prototype.unwrap_or_null = function () {\n        if (this.valid) {\n            return this.value;\n        }\n        return null;\n    };\n    Option.prototype.expect = function (err) {\n        if (!this.valid) {\n            throw new Error(err);\n        }\n        return this.value;\n    };\n    Option.prototype.is_some = function () {\n        return this.valid;\n    };\n    Option.prototype.is_none = function () {\n        return !this.valid;\n    };\n    Option.prototype.map = function (fn) {\n        if (this.valid) {\n            var new_some = fn(this.value);\n            return Option.some(new_some);\n        }\n        else {\n            return Option.none();\n        }\n    };\n    return Option;\n}());\nexports.Option = Option;\n\n\n//# sourceURL=webpack://dkk/./js_src/util/result.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js_src/index.js");
/******/ 	
/******/ })()
;